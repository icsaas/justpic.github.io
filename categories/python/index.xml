<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on 桑河一榆</title><link>https://justpic.org/categories/python/</link><description>Recent content in python on 桑河一榆</description><generator>justpic</generator><language>zh-CN</language><managingEditor>matrix.orz@gmail.com (justpic)</managingEditor><webMaster>matrix.orz@gmail.com (justpic)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 06 Apr 2020 01:00:32 +0800</lastBuildDate><atom:link href="https://justpic.org/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>口罩和安全帽识别</title><link>https://justpic.org/post/2020/04/06/mask-helmet-recognition/</link><pubDate>Mon, 06 Apr 2020 01:00:32 +0800</pubDate><author>matrix.orz@gmail.com (justpic)</author><guid>https://justpic.org/post/2020/04/06/mask-helmet-recognition/</guid><description><p>2019年以来，图像识别类竞赛也开始集中到口罩和安全帽这两类与健康安全息息相关的场景中，下面主要从这两类场景的一些竞赛资料和比赛流程进行一个简短的介绍，</p><div class="hugo-encryptor-container"><div class="hugo-encryptor-prompt"><p>文章的部分内容被密码保护：</p></div><div class="hugo-encryptor-form"><input class="hugo-encryptor-input" placeholder="请输入密码"/><input class="hugo-encryptor-button" type="button" value="点击验证" onclick="_click_handler(this)"/></div><div class="hugo-encryptor-cipher-text" data-password="cvmart2333" style="display: none;"><span style="display: none;">--- DON'T MODIFY THIS LINE ---</span><p>最开始，是通过极市小助手公众号得知极市组织了第一届图像识别类的比赛，比赛内容主要分为口罩识别和安全帽识别，我主要参与的是安全帽识别，在参加极市组织的安全帽比赛过程中，就比赛体验来说，
主要存在以下亮点：</p><ol><li>具有代码示例，极大的降低了入门门槛</li><li>使用jupyterlab环境进行远程命令操作，继承了较好的用户交互体验</li><li>认识了算法交易的一种新的商业模式，极市平台很好的连接了算法生产者和算法消费者，通过商城和开发平台两个不同的模块整合了算法资源，并持续运营。</li><li>认识了牛人，知道了Intel Openvino新技术以及常用的目标识别算法，ROI等概念。</li></ol><p>但同时感觉可能存在以下改进点：</p><ol><li>比赛过程中，参赛人员是不可以接触训练模型的，只能通过网页看到一些数据分析图片，模型调优较为困难，极大地消弱了参与比赛的积极性。</li><li>jupyterlab使用时长会消耗积分，关闭实例的同时会连带关闭jupyterlab，感觉jupyterlab本身并不消耗GPU资源，没有必要在关闭训练或者测试实例的时候同时关闭jupyterlab实例。</li><li>整个训练测试过程不够直观，需要经过线下编码、线上训练、线上转换模型、线上测试一系列的步骤才能最终得到结果，但中间过程仅通过查询日志才能进行排错，根据官方教程，我本地也建立了一套线下环境，总体感觉数据分析平台还只是一个demo，不能称之为产品，与阿里DOPS或者其他数析平台还有差距，相信极市内部应该还有一套更为成熟的数析平台。建议是否能够研发或者引进算法引擎、类工作流引擎来简化编写代码操作，记得2015年的时候阿里大数据比赛最开始的时候环境也是类似的，后面优化的力度和进度还是挺快的，不光建立了算法资源库，也产生了比较优秀的数析平台。</li></ol></div></div><hr><p><em>参考</em></p><ul><li><a href="http://www.python88.com/topic/49712" target="_blank" rel="noopener noreffer">深度学习实现安全帽的检测</a></li><li><a href="https://www.lizenghai.com/archives/32586.html" target="_blank" rel="noopener noreffer">基于YOLOV3进行安全帽检测</a></li><li><a href="https://www.yanxishe.com/blogDetail/14905" target="_blank" rel="noopener noreffer">ai研习社</a></li><li><a href="https://www.cnblogs.com/supersayajin/p/11445401.html" target="_blank" rel="noopener noreffer">安全帽检测数据集与与训练模型</a></li><li><a href="https://github.com/njvisionpower/Safety-Helmet-Wearing-Dataset" target="_blank" rel="noopener noreffer">安全帽检测数据集</a></li><li><a href="https://github.com/MinhNKB/helmet-safety-vest-detection" target="_blank" rel="noopener noreffer">安全帽检测github</a></li><li><a href="https://github.com/QinWinner/MFC-darknet-yolo" target="_blank" rel="noopener noreffer">mfc检测安全帽</a></li><li><a href="cvmart.net" rel="noopener noreffer">cvmart</a></li></ul></description></item><item><title>requests库中的那些高级用法</title><link>https://justpic.org/post/2020/03/12/requsts-advance-usage/</link><pubDate>Thu, 12 Mar 2020 22:21:33 +0800</pubDate><author>matrix.orz@gmail.com (justpic)</author><guid>https://justpic.org/post/2020/03/12/requsts-advance-usage/</guid><description><p>作为python中最通用的http工具库之一——requests，具有简洁、直观和全面的特点，一般来说，requests与python中的内置模块urllib3已经逐渐成为程序员处理HTTP请求的首选工具。</p><p>得益于requests简洁的API接口，在生产环境下得到了非常普遍的应用，即使在复杂的应用场景下，request的扩展性也非常好。如果你正在写一个API客户端或者网络爬虫，同时对断网情况比较棘手，那么下面所介绍的requests高级技巧可能会帮助你更好的进行程序调试。</p><h2 id="请求钩子">请求钩子</h2><p>应用第三方API时，需要验证应答内容是否合法，requests提供了raise_for_status()方法来判断应答内容的HTTP状态码是不是4xx或者5xx，表明请求产生了客户端或者服务器错误。</p><p>例如：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.github.com/user/repos?page=1'</span><span class="p">)</span><span class="c1"># 判断是否有无错误</span><span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span></code></pre></td></tr></table></div></div><p>每一次请求都调用raise_for_status会非常繁琐，requests非常贴心的提供了一个&rsquo;钩子(hook)&lsquo;接口（通过在请求过程的特定部分指定回调函数）。
下面请看案例代码，通过使用hook来确保每次服务应答后，raise_for_status能被调用。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">assert_status_hook</span><span class="o">=</span><span class="k">lambda</span><span class="n">response</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span><span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">hooks</span><span class="p">[</span><span class="s1">'response'</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">assert_status_hook</span><span class="p">]</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.github.com/user/repos?page=1")</span><span class="o">></span><span class="n">HTTPError</span><span class="p">:</span><span class="mi">401</span><span class="n">Client</span><span class="n">Error</span><span class="p">:</span><span class="n">Unauthorized</span><span class="k">for</span><span class="n">url</span><span class="p">:</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">api</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">repos</span><span class="err">?</span><span class="n">page</span><span class="o">=</span><span class="mi">1</span></code></pre></td></tr></table></div></div><h2 id="设置基链接">设置基链接</h2><p>假设你只使用api.org上的一个api，你可能在每次调用时都要重复编写http协议和域名。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.org/list'</span><span class="p">)</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.org/list/3/item'</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>使用BaseUrlSession可以避免敲下这些重复的内容。
下面看案例代码，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">form</span><span class="n">requests_toolbelt</span><span class="kn">import</span><span class="nn">sessions</span><span class="n">http</span><span class="o">=</span><span class="n">sessions</span><span class="o">.</span><span class="n">BaseUrlSession</span><span class="p">(</span><span class="n">base_url</span><span class="o">=</span><span class="s2">"https://api.org"</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/list"</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/list/item"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p><strong>！注意requests_toolbelt没有默认包含在requests中的，使用时是需要额外安装的</strong></p><h2 id="设置默认超时">设置默认超时</h2><p>requests文档中推荐在生产环境下设置超时，如果你忘记设置超时，应用程序可能会当掉，尤其是在同步环境下，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://github.com/'</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>但是每次设置超时时间会非常繁琐，偶尔忘记设置超时会非常恼火。<img class="lazyload" src="/svg/loading.small.min.svg" data-sizes="auto" data-srcset="/images/posts/giphy.gif,  1.5x,  2x" data-src="" alt="giphy" title="giphy"/></p><p>使用Transport Adapters可以为所有的HTTP调用设置默认超时时间，当然使用后也是可以通过再定义覆盖默认配置，
下面看案例代码，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span><span class="lnt">23</span><span class="lnt">24</span><span class="lnt">25</span><span class="lnt">26</span><span class="lnt">27</span><span class="lnt">28</span><span class="lnt">29</span><span class="lnt">30</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span><span class="nn">requests.adapters</span><span class="kn">import</span><span class="n">HTTPAdapter</span><span class="n">DEFAULT_TIMEOUT</span><span class="o">=</span><span class="mi">5</span><span class="k">class</span><span class="nc">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">HTTPAdapter</span><span class="p">):</span><span class="k">def</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="o">=</span><span class="n">DEFAULT_TIMEOUT</span><span class="k">if</span><span class="s2">"timeout"</span><span class="ow">in</span><span class="n">kwargs</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="k">del</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="k">def</span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">request</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="n">timeout</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"timeout"</span><span class="p">)</span><span class="k">if</span><span class="n">timeout</span><span class="ow">is</span><span class="bp">None</span><span class="p">:</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="k">return</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="c1">#使用</span><span class="kn">import</span><span class="nn">requests</span><span class="n">http</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">adapter</span><span class="o">=</span><span class="n">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"http://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="c1">#使用默认配置</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.weibo.com'</span><span class="p">)</span><span class="c1">#覆盖默认配置</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.weibo.com'</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code></pre></td></tr></table></div></div><h2 id="失败后的重试">失败后的重试</h2><p>服务器当掉后，网络连接会变得拥塞或者有损，如果想要建立更具鲁棒性的系统，那么必须考虑网络连接失败，以及建立重试策略。
在Http客户端上添加重试策略是非常直接的，我们来创建一个HTTPAdapter，然后在adapter上添加策略</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span><span class="nn">requests.adapter</span><span class="kn">import</span><span class="n">HTTPAdapter</span><span class="kn">from</span><span class="nn">requests.packages.urllib3.util.retry</span><span class="kn">import</span><span class="n">Retry</span><span class="n">retry_strategy</span><span class="o">=</span><span class="n">Retry</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">429</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">502</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">],</span><span class="n">method_whitelist</span><span class="o">=</span><span class="p">[</span><span class="s2">"HEAD"</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">,</span><span class="s2">"OPTIONS"</span><span class="p">]</span><span class="p">)</span><span class="n">adapter</span><span class="o">=</span><span class="n">HTTPAdapter</span><span class="p">(</span><span class="n">max_retries</span><span class="o">=</span><span class="n">retry_strategy</span><span class="p">)</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"http://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://en.wikipedia.org/w/api.php"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>默认的 Retry 类提供了健全的默认值，但是是高度可配置的，所以这里是我使用的最常见参数的纲要。
其中</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">total</span><span class="o">=</span><span class="mi">3</span></code></pre></td></tr></table></div></div><p>total代表重试的总次数，如果失败的请求或者重定向的次数超过这个数字，客户端将抛出 urllib3.exceptions.Maxretryerror 异常。通常3次重试就足够了。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">413</span><span class="p">,</span><span class="mi">429</span><span class="p">,</span><span class="mi">503</span><span class="p">]</span></code></pre></td></tr></table></div></div><p>要重试的 HTTP 响应代码。 您可能希望对常见的服务器错误(500、502、503、504)进行重试，因为服务器和反向代理并不总是遵循 HTTP 规范。 总是在超出429速率限制的情况下重试，因为默认情况下，urllib 库应该在失败请求时增量地退出。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">method_whitelist</span><span class="o">=</span><span class="p">[</span><span class="s2">"HEAD"</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">,</span><span class="s2">"PUT"</span><span class="p">,</span><span class="s2">"DELETE"</span><span class="p">,</span><span class="s2">"OPTIONS"</span><span class="p">,</span><span class="s2">"TRACE"</span><span class="p">]</span></code></pre></td></tr></table></div></div><p>要重试的 HTTP 方法。 默认情况下，这包括除 POST 以外的所有 HTTP 方法，因为 POST 可能导致新的插入。 修改此参数以包含 POST，因为大多数 i 处理的 API 不返回错误代码并在同一调用中执行插入操作。 如果他们这样做了，您可能应该发布一个 bug 报告。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">backoff_factor</span><span class="o">=</span><span class="mi">0</span></code></pre></td></tr></table></div></div><p>backoff_factor(退避因子)与失败的请求之间休眠的时间有关，其算法如下：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="p">{</span><span class="n">backoff</span><span class="n">factor</span><span class="p">}</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">({</span><span class="n">number</span><span class="n">of</span><span class="n">total</span><span class="n">retries</span><span class="p">}</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></code></pre></td></tr></table></div></div><p>例如，如果退避因子设置为:
1：连续睡眠：0.5，1，2，4，8，16，32，64，128，256
2：连续睡眠：1，2，4，8，16，32，64，128，256，512
10：连续睡眠：5，10，20，40，80，160，320，640，1280，2560
作为重试策略的合理默认实现，连续睡眠值是呈指数增长的，通过设置退避因子，可以决定每个睡眠乘以多少。这个值默认为0，表示不会设置截断二进制指数退避算法，重试将立即执行。</p><h3 id="结合超时和重试">结合超时和重试</h3><p>由于 HTTPAdapter 具有类比的特性，我们可以像下面这样将重试和超时结合起来:</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">retries</span><span class="o">=</span><span class="n">Retry</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">backoff_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">429</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">502</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">])</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">max_retries</span><span class="o">=</span><span class="n">retries</span><span class="p">))</span></code></pre></td></tr></table></div></div><h2 id="调试http请求">调试HTTP请求</h2><p>有时候请求会失败，而你却不知道为什么。 记录请求和响应可以帮助您了解故障。 有两种方法可以做到这一点——要么使用内置的调试日志记录设置，要么使用请求钩子。</p><h3 id="打印http头文件">打印HTTP头文件</h3><p>更改大于0的日志记录调试级别将记录响应 HTTP 报头。 这是最简单的选项，但它不允许您查看 HTTP 请求或响应体。 如果您处理的 API 返回一个不适合日志记录或包含二进制内容的大体有效负载，那么它是有用的。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="kn">import</span><span class="nn">http</span><span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="o">.</span><span class="n">debuglevel</span><span class="o">=</span><span class="mi">1</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://www.google.com/"</span><span class="p">)</span><span class="c1"># Output</span><span class="n">send</span><span class="p">:</span><span class="sa">b</span><span class="s1">'GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: www.google.com</span><span class="se">\r\n</span><span class="s1">User-Agent: python-requests/2.22.0</span><span class="se">\r\n</span><span class="s1">Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s1">Accept: */*</span><span class="se">\r\n</span><span class="s1">Connection: keep-alive</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="n">reply</span><span class="p">:</span><span class="s1">'HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s1">'</span><span class="n">header</span><span class="p">:</span><span class="n">Date</span><span class="p">:</span><span class="n">Fri</span><span class="p">,</span><span class="mi">28</span><span class="n">Feb</span><span class="mi">2020</span><span class="mi">12</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">26</span><span class="n">GMT</span><span class="n">header</span><span class="p">:</span><span class="n">Expires</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">header</span><span class="p">:</span><span class="n">Cache</span><span class="o">-</span><span class="n">Control</span><span class="p">:</span><span class="n">private</span><span class="p">,</span><span class="nb">max</span><span class="o">-</span><span class="n">age</span><span class="o">=</span><span class="mi">0</span></code></pre></td></tr></table></div></div><h3 id="打印所有">打印所有</h3><p>如果您想记录整个 HTTP 生命周期，包括请求和响应的文本表示，那么您可以使用请求钩子和请求工具自带的转储组件。
在处理基于 REST 的 API 时，我更喜欢这个选项，因为它不会返回非常大的响应。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span><span class="lnt">23</span><span class="lnt">24</span><span class="lnt">25</span><span class="lnt">26</span><span class="lnt">27</span><span class="lnt">28</span><span class="lnt">29</span><span class="lnt">30</span><span class="lnt">31</span><span class="lnt">32</span><span class="lnt">33</span><span class="lnt">34</span><span class="lnt">35</span><span class="lnt">36</span><span class="lnt">37</span><span class="lnt">38</span><span class="lnt">39</span><span class="lnt">40</span><span class="lnt">41</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="kn">from</span><span class="nn">requests_toolbelt.utils</span><span class="kn">import</span><span class="n">dump</span><span class="k">def</span><span class="nf">logging_hook</span><span class="p">(</span><span class="n">response</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="n">data</span><span class="o">=</span><span class="n">dump</span><span class="o">.</span><span class="n">dump_all</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">))</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">hooks</span><span class="p">[</span><span class="s2">"response"</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">logging_hook</span><span class="p">]</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://api.openaq.org/v1/cities"</span><span class="p">,</span><span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">"country"</span><span class="p">:</span><span class="s2">"BA"</span><span class="p">})</span><span class="c1"># Output</span><span class="o">&lt;</span><span class="n">GET</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">cities</span><span class="err">?</span><span class="n">country</span><span class="o">=</span><span class="n">BA</span><span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span><span class="o">&lt;</span><span class="n">Host</span><span class="p">:</span><span class="n">api</span><span class="o">.</span><span class="n">openaq</span><span class="o">.</span><span class="n">org</span><span class="o">></span><span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span><span class="mi">200</span><span class="n">OK</span><span class="o">></span><span class="n">Content</span><span class="o">-</span><span class="n">Type</span><span class="p">:</span><span class="n">application</span><span class="o">/</span><span class="n">json</span><span class="p">;</span><span class="n">charset</span><span class="o">=</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="o">></span><span class="n">Transfer</span><span class="o">-</span><span class="n">Encoding</span><span class="p">:</span><span class="n">chunked</span><span class="o">></span><span class="n">Connection</span><span class="p">:</span><span class="n">keep</span><span class="o">-</span><span class="n">alive</span><span class="o">></span><span class="p">{</span><span class="s2">"meta"</span><span class="p">:{</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"openaq-api"</span><span class="p">,</span><span class="s2">"license"</span><span class="p">:</span><span class="s2">"CC BY 4.0"</span><span class="p">,</span><span class="s2">"website"</span><span class="p">:</span><span class="s2">"https://docs.openaq.org/"</span><span class="p">,</span><span class="s2">"page"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s2">"limit"</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="s2">"found"</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="s2">"results"</span><span class="p">:[</span><span class="p">{</span><span class="s2">"country"</span><span class="p">:</span><span class="s2">"BA"</span><span class="p">,</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Goražde"</span><span class="p">,</span><span class="s2">"city"</span><span class="p">:</span><span class="s2">"Goražde"</span><span class="p">,</span><span class="s2">"count"</span><span class="p">:</span><span class="mi">70797</span><span class="p">,</span><span class="s2">"locations"</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="p">]</span><span class="p">}</span></code></pre></td></tr></table></div></div><h2 id="测试和模拟请求">测试和模拟请求</h2><p>在开发中使用第三方 API 会引入一个痛点——很难进行单元测试。 为减轻这种痛苦，Sentry 的工程师在开发过程中编写了一个模拟请求的库。</p><blockquote><p>不是将 HTTP 响应发送给服务器 getsentry / responses，而是截取 HTTP 请求，在应答时，测试过程中添加预定义的响应内容。</p></blockquote><p>下面请看案例代码</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">unittest</span><span class="kn">import</span><span class="nn">requests</span><span class="kn">import</span><span class="nn">responses</span><span class="k">class</span><span class="nc">TestAPI</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><span class="nd">@responses.activate</span><span class="c1"># intercept HTTP calls within this method</span><span class="k">def</span><span class="nf">test_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="n">response_data</span><span class="o">=</span><span class="p">{</span><span class="s2">"id"</span><span class="p">:</span><span class="s2">"ch_1GH8so2eZvKYlo2CSMeAfRqt"</span><span class="p">,</span><span class="s2">"object"</span><span class="p">:</span><span class="s2">"charge"</span><span class="p">,</span><span class="s2">"customer"</span><span class="p">:</span><span class="p">{</span><span class="s2">"id"</span><span class="p">:</span><span class="s2">"cu_1GGwoc2eZvKYlo2CL2m31GRn"</span><span class="p">,</span><span class="s2">"object"</span><span class="p">:</span><span class="s2">"customer"</span><span class="p">},</span><span class="p">}</span><span class="c1"># mock the Stripe API</span><span class="n">responses</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">GET</span><span class="p">,</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">,</span><span class="n">json</span><span class="o">=</span><span class="n">response_data</span><span class="p">,</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">)</span><span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">(),</span><span class="n">response_data</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>如果发出的 HTTP 请求与模拟响应不匹配，则会抛出 ConnectionError。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span><span class="nc">TestAPI</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><span class="nd">@responses.activate</span><span class="k">def</span><span class="nf">test_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="n">responses</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">GET</span><span class="p">,</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://invalid-request.com"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>输出：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span><span class="lnt">6</span><span class="lnt">7</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">:</span><span class="n">Connection</span><span class="n">refused</span><span class="n">by</span><span class="n">Responses</span><span class="o">-</span><span class="n">the</span><span class="n">call</span><span class="n">doesn</span><span class="s1">'t match any registered mock.</span><span class="n">Request</span><span class="p">:</span><span class="o">-</span><span class="n">GET</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">invalid</span><span class="o">-</span><span class="n">request</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">Available</span><span class="n">matches</span><span class="p">:</span><span class="o">-</span><span class="n">GET</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">api</span><span class="o">.</span><span class="n">stripe</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">charges</span></code></pre></td></tr></table></div></div><h2 id="模仿浏览器行为">模仿浏览器行为</h2><p>如果你已经写了足够多的网络爬虫代码，你将会注意到某些网站会根据浏览器或者请求方式返回不同的 HTML内容。 有时这是一种反抓取措施，但通常服务器会进行用户代理嗅探，以找出最适合设备的内容(例如桌面或移动设备)。
如果你想返回与浏览器显示的内容相同的内容，你可以使用 Firefox 或 Chrome 发送的内容覆盖默认的 User-Agent 头请求集。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">"User-Agent"</span><span class="p">:</span><span class="s2">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0"</span><span class="p">})</span></code></pre></td></tr></table></div></div><hr><p>参考：</p><ul><li><a href="https://hodovi.ch/blog/advanced-usage-python-requests-timeouts-retries-hooks/" target="_blank" rel="noopener noreffer">Advanced usage of Python requests - timeouts, retries, hooks</a></li></ul></description></item><item><title>Jupyter最佳实践</title><link>https://justpic.org/post/2020/03/09/jupyter-best-practice/</link><pubDate>Mon, 09 Mar 2020 23:30:29 +0800</pubDate><author>matrix.orz@gmail.com (justpic)</author><guid>https://justpic.org/post/2020/03/09/jupyter-best-practice/</guid><description><p>广受各大企业赞助的<a href="https://jupyter.org/about" target="_blank" rel="noopener noreffer">jupyter团队</a>
所开发的jupyter系列产品(主要包括jupyter notebook、jupyterlab和jupyterhub)，在数据科学领域变得越来越火热，依托python强大的语言生态，得益于其良好的扩展性和友好的用户交互，jupyter逐渐成为数据分析可视化的首选开源工具之一，下面将对数据分析实践过程中针对jupyter的调研分析进行小结.如果你正在使用python语言进行相关数据分析，本文所记录的jupyter相关实践可能对你会有所帮助。</p><div class="hugo-encryptor-container"><div class="hugo-encryptor-prompt"><p>文章的部分内容被密码保护：</p></div><div class="hugo-encryptor-form"><input class="hugo-encryptor-input" placeholder="请输入密码"/><input class="hugo-encryptor-button" type="button" value="点击验证" onclick="_click_handler(this)"/></div><div class="hugo-encryptor-cipher-text" data-password="123345" style="display: none;"><span style="display: none;">--- DON'T MODIFY THIS LINE ---</span></div></div><hr><blockquote><p>本文将主要从jupyter产品介绍、产品（jupyter notebook、jupyter lab和jupyterhub）的安装试用、jupyter 扩展优化、以及jupyter竞品分析等四大方面对jupyter的实践进行一个简短的介绍和回顾：</p></blockquote><h2 id="jupyter产品介绍">jupyter产品介绍：</h2><p>根据jupyter官方网站，jupyter产品主要包括jupyter notebook、jupyter lab和jupyterhub三款产品，根据文章<code>jupyter notebook、jupyterlab与jupyterhub的区别与联系</code><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>,三者的联系和区别如下：</p><ol><li>jupyter notebook提供了一个交互友好的类webIDE环境，但Jupyter Notebook 是传统的单体服务架构模式, 缺少多用户管理和访问认证等方面的功能, 无法直接部署于计算集群上, 难以充分利用和调度计算中心的计算资源 。</li><li>jupyter lab提供了单用户管理和认证，没有提供独立的工作空间，与jupyter notebook相比，功能更为丰富。</li><li>jupyter hub提供了多用户管理和认证，支持OAuth协议，为用户提供了独立的工作空间，工作内容可以私有不共享。</li></ol><p>在了解了jupyter系列产品后，就可以进行产品的安装和使用了。当然你也可以参考这些文章2<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>和3<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>、4<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>、5<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>来快速入门jupyter的使用.</p><h2 id="产品安装使用">产品安装使用</h2><h3 id="安装">安装</h3><blockquote><p>根据以上的产品介绍，可以根据自己的需求选择安装jupyter notebook、jupyter lab还是jupyterhub。具体参考建议如下：</p><ol><li>个人本地使用，安装快速方便&ndash;jupyter notebook</li><li>个人使用，可能会远程操作，需要额外的安装工作&ndash;jupyter lab</li><li>小型团队使用，可能需要额外的运维工作&ndash; jupyter hub</li></ol></blockquote><p><strong>安装jupyter notebook</strong><br>
jupyter notebook目前已经包含在Anaconda安装包中，随Anaconda将一同安装，不需要额外的安装操作，如果你想了解更多jupyter notebook安装细节，可以参考文章<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>和文章<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>。</p><p><strong>安装jupyter lab</strong><br>
jupyter lab可以通过pip，conda命令(Anaconda环境)作为jupyter notebook的扩展进行选装。
安装命令如下：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-shell" data-lang="shell">pip install jupyterlab<span class="c1">#或者</span>
conda install -c conda-forge jupyterlab</code></pre></td></tr></table></div></div><p>使用过程中，jupyterlab的作用更像一个功能强大的webshell，除支持文件上传，命令行等操作外，能够更直观地管理jupyter notebook的其他扩展。</p><p><strong>安装jupyterhub</strong><br>
jupyterhub的docker化安装步骤如下：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">#step1.创建共享目录</span><span class="nv">$mkdir</span> -p<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/jupyterhub/jupyterhub<span class="nv">$mkdir</span> -p<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/jupyterhub/home<span class="c1">#step2.启动镜像</span><span class="c1">#docker run -p 8000:8000 -d --name jupyterhub -v /opt/jupyterhub/jupyterhub:/srv/jupyterhub -v /opt/jupyterhub/home:/home --restart=always jupyterhub/jupyterhub jupyterhub</span>
docker run -p 8000:8000 -d --name jupyterhub -v<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/jupyterhub/jupyterhub:/srv/jupyterhub -v<span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/jupyterhub/home:/home jupyterhub/jupyterhub jupyterhub<span class="c1">#step3.进入到容器内操作</span>
docker<span class="nb">exec</span> -it jupyterhub bash
chmod -R<span class="m">777</span> /home<span class="c1">#step4.添加用户和设置密码</span>
useradd jupyterhub
passwd jupyterhub<span class="c1">#step5.浏览器访问测试</span>
http://<span class="o">{</span>yourip<span class="o">}</span>:8000
!替换yourip为本机ip地址</code></pre></td></tr></table></div></div><h3 id="使用">使用</h3><p><strong>启动jupyter</strong></p><ol><li>启动jupyter notebook<div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-shell" data-lang="shell">jupyter notebook<span class="c1"># 更多命令可额外输入--help进行查看</span></code></pre></td></tr></table></div></div></li><li>启动jupyter lab<div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-shell" data-lang="shell">jupyter lab<span class="c1"># 更多命令可额外输入--help进行查看</span></code></pre></td></tr></table></div></div></li></ol><p><strong>excel表格处理</strong><br>
jupyternotebook中使用pandas可以方便的处理excel文件，简单的差集、并集、交集运算使用几句简单的代码即可完成。<br><strong>数据可视化分析</strong><br>
结合pandas工具包可以非常方便的进行数据的基础分析，使用plot工具包可以完成交互性比较友好的动态数据分析图表。</p><h2 id="jupyter扩展">jupyter扩展</h2><p>为了提升jupyter的使用体验，目前已经有非常多的jupyter扩展可供使用，其范围除了优化其本身可视化交互体验之外，还涵盖了排版、多语言支持等功能。<br>
文章8<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>介绍了常用的99种jupyter扩展，
文章9<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>中所介绍的扩展主要围绕人工智能（AI）进行展开，
文章10<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup>介绍了提升jupyter使用环境体验的相关实践，
文章11<sup id="fnref:11"><a href="#fn:11" class="footnote-ref" role="doc-noteref">11</a></sup>介绍了扩展jupyter的99种方法，
文章12<sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup>介绍了生成pages的方法，
文章13<sup id="fnref:13"><a href="#fn:13" class="footnote-ref" role="doc-noteref">13</a></sup>中通过低代码方式使用jupyter notebook，进一步降低了jupyter的难度、提高了jupyter的交互友好度。
文章14<sup id="fnref:14"><a href="#fn:14" class="footnote-ref" role="doc-noteref">14</a></sup>主要介绍了jupyter notebook的基础架构，如果需要进行进一步应用开发集成，对其基础架构了解是必须的。</p><p><strong>pyspark集成</strong><br>
大数据相关技术的发展，jupyter支持与spark进行相关集成</p><h3 id="技术架构分析">技术架构分析</h3><p>jupyter 使用了较新的web技术（Websocket等）来保证用户交互的友好性，提供了一种混合的编辑方式, 将程序
代码运行、文字图表编辑等功能糅合在同一电子笔记中, 打破了两者之间的隔离界限.fastpage<sup id="fnref:12"><a href="#fn:12" class="footnote-ref" role="doc-noteref">12</a></sup>介绍了将jupyternotebook内容导出为page，可以直接应用于博客或者出版，进一步提高了jupyter的可扩展性。为了集成和二次开发jupyter，通过文章<code>技术架构分析</code><sup id="fnref:14"><a href="#fn:14" class="footnote-ref" role="doc-noteref">14</a></sup>中对jupyter的技术架构进行简单的了解，得出如下jupyter架构图，<br><img class="lazyload" src="/svg/loading.small.min.svg" data-sizes="auto" data-srcset="/images/posts/jupyter-arch.jpg,  1.5x,  2x" data-src="" alt="架构图" title="架构图"/></p><h2 id="jupyter竞品分析">jupyter竞品分析</h2><p>通过搜索，Netflix发布的Polynote<sup id="fnref:15"><a href="#fn:15" class="footnote-ref" role="doc-noteref">15</a></sup>有可能成为jupyter的竞品，除此之外，阿里巴巴、kaggle以及大多数据竞赛平台也开始提供类似jupyter的数据分析平台以方便开发者快速使用。</p><p>如果你有更好的想法和建议，欢迎留言。</p><hr><p><strong>参考</strong></p><section class="footnotes" role="doc-endnotes"><hr><ol><li id="fn:1" role="doc-endnote"><p><a href="https://www.imooc.com/article/300868" target="_blank" rel="noopener noreffer">jupyter notebook、jupyterlab与jupyterhub的区别与联系</a><a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:2" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/O3vXXaqG9-E7mRT-_wARWw" target="_blank" rel="noopener noreffer">数据科学和机器学习，jupyternotebook入门指南</a><a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:3" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/aJRVh7BWOMq4KCoBMtLGGw" target="_blank" rel="noopener noreffer">快速学习jupyternotebook</a><a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:4" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/24B1TSmMPYphXI-0ij3fJQ" target="_blank" rel="noopener noreffer">jupyter notebook数据格式解析</a><a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:5" role="doc-endnote"><p><a href="https://justpic.org/post/latex-math-symbol/" target="_blank" rel="noopener noreffer">latex数学符号</a><a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:6" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/PJmVJ-pESb6bkLf9Nq-A1Q" target="_blank" rel="noopener noreffer">十分钟搭建你的jupyternotebook服务器</a><a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:7" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/1nTP7uLAJuOYW-WXVE_-cg" target="_blank" rel="noopener noreffer">使用jupyternotebook进行远程炼丹</a><a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:8" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/BSim0lMo0T0JiunnKqHzNg" target="_blank" rel="noopener noreffer">让jupyter更强大的99中武器</a><a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:9" role="doc-endnote"><p><a href="https://github.com/elyra-ai/elyra" target="_blank" rel="noopener noreffer">Elyra：基于AI技术的JupyterLab实用扩展集</a><a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:10" role="doc-endnote"><p><a href="https://medium.com/m/global-identity?redirectUrl=https%3A%2F%2Ftowardsdatascience.com%2Felevate-your-jupyter-notebook-environment-experience-9bdd1101aa54" target="_blank" rel="noopener noreffer">Elevate Your Jupyter Notebook Environment Experience</a><a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:11" role="doc-endnote"><p><a href="https://python.freelycode.com/contribution/detail/1632" target="_blank" rel="noopener noreffer">扩展Jupyter生态系统的99种方法</a><a href="#fnref:11" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:12" role="doc-endnote"><p><a href="https://fastpages.fast.ai/fastpages/jupyter/2020/02/21/introducing-fastpages.html" target="_blank" rel="noopener noreffer">jupyter生成pages</a><a href="#fnref:12" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:13" role="doc-endnote"><p><a href="https://github.com/herqooly/herqooly" target="_blank" rel="noopener noreffer">低代码方式使用jupyter</a><a href="#fnref:13" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:14" role="doc-endnote"><p><a href="https://blog.just4fun.site/post/%E6%9E%B6%E6%9E%84/jupyter-notebook-architecture/" target="_blank" rel="noopener noreffer">jupyter notebook架构分析</a><a href="#fnref:14" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li><li id="fn:15" role="doc-endnote"><p><a href="https://mp.weixin.qq.com/s/bwtENwhO7EFQqW5XJduJ-A" target="_blank" rel="noopener noreffer">还有比 Jupyter 更好用的工具</a><a href="#fnref:15" class="footnote-backref" role="doc-backlink">&#8617;&#xfe0e;</a></p></li></ol></section></description></item></channel></rss>