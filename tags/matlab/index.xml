<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>matlab on 桑河一榆</title><link>https://justpic.org/tags/matlab/</link><description>Recent content in matlab on 桑河一榆</description><generator>justpic</generator><language>zh-CN</language><managingEditor>matrix.orz@gmail.com (justpic)</managingEditor><webMaster>matrix.orz@gmail.com (justpic)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 06 May 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://justpic.org/tags/matlab/index.xml" rel="self" type="application/rss+xml"/><item><title>Matlab C混合编程</title><link>https://justpic.org/post/2014/05/06/matlab-mixed-c/</link><pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate><author>matrix.orz@gmail.com (justpic)</author><guid>https://justpic.org/post/2014/05/06/matlab-mixed-c/</guid><description><p>Matalb与C/C__语言混合编程</p><blockquote><p>用C++（或者C）语言操作MATLAB，有三种途径：MEX、MAT、引擎应用程序</p></blockquote><h4 id="1mex文件">1.MEX文件</h4><p>在MATLAB中可调用的C或Fortran语言程序称为MEX文件。MATLAB可以直接把MEX文件视为它的内建函数进行调用。MEX文件是动态链接的子例程，MATLAB解释器可以自动载入并执行它。MEX文件主要有以下用途：<br>
对于大量现有的C或者Fortran程序可以无须改写成MATLAB专用的M文件格式而在MATLAB中执行。<br>
对于那些MATLAB运算速度过慢的算法，可以用C或者Frotran语言编写以提高效率。</p><h4 id="2mat文件应用程序">2.MAT文件应用程序</h4><p>MAT文件是MATLAB专用的用于保存数据至磁盘和向MATLAB导入、从MATLAB导出数据的数据文件格式。MAT文件提供了一种简便的机制，它允许你在两个平台之间以灵活的方式移动数据。而且，它还提供了一种途径来向其它单机MATLAB应用导入或者导出数据。<br>
为了简化在MATLAB环境之外对MAT文件的使用，MATLAB给出了一个操作例程库，通过它，我们可以使用C/C++或者Fortran程序读写MAT文件。</p><h4 id="3引擎应用程序">3.引擎应用程序</h4><p>MATLAB提供了一系列的例程使得别的程序可以调用MATLAB，从而把MATLAB用作一个计算引擎。MATLAB引擎程序指的是那些通过管道（在UNIX系统中）或者ActiveX（在Windows系统中）与独立MATLAB进程进行通信的C/C++或者Fortran程序。<br>
MEX文件</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span><span class="lnt">23</span><span class="lnt">24</span><span class="lnt">25</span><span class="lnt">26</span><span class="lnt">27</span><span class="lnt">28</span><span class="lnt">29</span><span class="lnt">30</span><span class="lnt">31</span><span class="lnt">32</span><span class="lnt">33</span><span class="lnt">34</span><span class="lnt">35</span><span class="lnt">36</span><span class="lnt">37</span><span class="lnt">38</span><span class="lnt">39</span><span class="lnt">40</span><span class="lnt">41</span><span class="lnt">42</span><span class="lnt">43</span><span class="lnt">44</span><span class="lnt">45</span><span class="lnt">46</span><span class="lnt">47</span><span class="lnt">48</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-fallback" data-lang="fallback">#include “mex.h”
/*
*timestwo.c-example found in API guide
*
*Computational function that takes a scalar and doubles it
*
*This is a MEX-File for MATLAB.
*Copyright(c)
*/
void timestwo(double y[],double x[]);
void timestwo(double y[],double x[])
{
y[0]=2.0*x[0];
}
void mexFunction(int nlhs,mxArray* plhs[],int nrhs,const mxArray *prhs[])
/*nlhs是MATLAB命令行方式下输出参数的个数
*plhs是MATLAB命令行方式下的输出参数;
*nrhs是MATLAB命令行方式下输入参数的个数；
*prhs[]是MATLAB命令行方式下的输入参数；
*/
{
double *x,*y;
int mrows,ncols;
/*Check for proper number of arguments.*/
if (nrhs!=1){
mexErrMsgTxt(“One input required”);
}
else if(nlhs>=1)
{
mexErrMsgTxt(“Too many output arguments”);
}
/*在MATLAB命令行方式下，本MEX文件的调用格式是y=timestwo(x)
输入参数（x）个数=1，输出参数（y）个数=1，所以在程序一开始就检查
nrhs时候==1以及nlhs是否>=1（因为MATLAB有一个缺省的输出参数ans，所以nlhs可以==0*/
/*The input must be a non comlex scalar double.*/
mrows=mxGetM(prhs[0]);//矩阵行数&lt;br>
ncols=mxGetN(prhs[0]);//矩阵列数&lt;br>
if (!mxIsDouble(prhs[0])|| mxIsComplex(prhs[0])||!(mrows==1&amp;amp;ncols==1))
{
mexErrMsgTxt(“Input must be a noncomplex scalar double”);
}
//判断输入举证是否是double类，以及它是否只包含单个元素无嵌套
//为输出创建一个矩阵，显然这个矩阵也应该是1*1的
plhs[0]=mxCreateDoubleMatrix(mrows,ncols,mxREAL);
x=mxGetPr(prhs[0]);
y=mxGetPr(plhs[0]);
timestwo(y,x);
}</code></pre></td></tr></table></div></div><p>matlab命令行上输入以下语句：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-fallback" data-lang="fallback">mex testmex.cpp;
x=2;
y=testmex(x);</code></pre></td></tr></table></div></div><blockquote><p>MAT文件：<br>
libmat.dll:用于操作mat文件<br>
libmx.dll:用于操作mat文件中的矩阵<br>
MATLAB中常用的矩阵类型：</p></blockquote><p>(复)双精度矩阵：<br>
MATLAB中最常用的数据类型便是（复）双精度、非稀疏矩阵，这些矩阵的元素都是双精度（double）的，矩阵的尺寸为m×n，其中m是总行数，m是总列数。矩阵数据实际存放在两个双精度向量中——一个向量存放的是数据的实部，另一个向量存放的是数据的虚部。指向这两个向量的指针一般被写做“pr” （pointer to real data，指向实数据的指针）和“pi” （pointer to imaginary data，指向虚数据的指针）”。如果一个矩阵的pi为空的话，说明它是实双精度矩阵。<br>
稀疏矩阵（Sparse Matrices）<br>
MATLAB中稀疏矩阵的存储格式与众不同。如同双精度矩阵一样，它拥有参数pr和pi，同时它还具用三个附加的参数：nzmax，ir以及jc。<br>
nzmax是个整型数，其值为向量ir及pr、pi（如果存在的话）可能的最大长度。它是稀疏矩阵中不为零的元素的个数。
ir指向一个长度为nzmax的整型数阵列，阵列包含的是pr和pi中对应元素的行号。<br>
jc指向一个长度为N+1的整型数阵列（N为矩阵的列数），其中包含的是列号信息。对于任意的j，如果0≤j≥N-1，jc[j]是第j列中第一个非零项在ir、pr（以及pi）中的序号，jc[j+1]-1是第j列最后一个非零项的序号。因此jc[N]总等于nnz——矩阵中非零项的总个数。如果nnz小于nzmax，可以继续向矩阵中添加非零项而无需分配额外的存储空间&lt;</p><p>主要函数举例:</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-fallback" data-lang="fallback">·MATFile *matOpen(const char *filename, const char * mode)——打开/创建
·MATFile *matOpen(const char *filename, const char * mode)——打开/创建一个MAT文件；
·int matClose(MATFile *pMF)——关闭一个MAT文件；
·mxArray *mxCreateDoubleMatrix(int m, int n, mxComplexity flag)
#创建一个（复）双精度矩阵；
·mxArray *mxCreateSparse(int m, int n, int nzmax, mxComplexity flag)
#创建一个稀疏矩阵；
·mxArray *matGetNextArray(MATFile *pMF)——获得MAT文件里面下一个矩阵；
·const char *mxGetName(const mxArray *pa)——获得矩阵pa的名称；
·void mxSetName(mxArray *pa,const char *s)——为矩阵pa设置一个名称；
·int mxGetM(const mxArray *pa)——获得矩阵pa的总行数；
·int mxGetN(const mxArray *pa)——获得矩阵pa的总列数；
·double *mxGetPr(const mxArray *pa)——获得矩阵pa的pr指针；
·int *mxGetIr(const mxArray *pa)——获得稀疏矩阵pa的ir指针；
·int *mxGetJc(const mxArray *pa)——获得稀疏矩阵pa的jc指针；
·int matPutArray(MATFile * pMF, const mxArray * pA)
#把矩阵pA存储入MAT文件pMAF；
·void mxDestroyArray(mxArray *pa)——释放矩阵pa（把它从内存中撤销）；</code></pre></td></tr></table></div></div></description></item></channel></rss>