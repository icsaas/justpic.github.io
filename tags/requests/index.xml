<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>requests on 桑河一榆</title><link>https://justpic.org/tags/requests/</link><description>Recent content in requests on 桑河一榆</description><generator>justpic</generator><language>zh-CN</language><managingEditor>matrix.orz@gmail.com (justpic)</managingEditor><webMaster>matrix.orz@gmail.com (justpic)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 12 Mar 2020 22:21:33 +0800</lastBuildDate><atom:link href="https://justpic.org/tags/requests/index.xml" rel="self" type="application/rss+xml"/><item><title>requests库中的那些高级用法</title><link>https://justpic.org/post/2020/03/12/requsts-advance-usage/</link><pubDate>Thu, 12 Mar 2020 22:21:33 +0800</pubDate><author>matrix.orz@gmail.com (justpic)</author><guid>https://justpic.org/post/2020/03/12/requsts-advance-usage/</guid><description><p>作为python中最通用的http工具库之一——requests，具有简洁、直观和全面的特点，一般来说，requests与python中的内置模块urllib3已经逐渐成为程序员处理HTTP请求的首选工具。</p><p>得益于requests简洁的API接口，在生产环境下得到了非常普遍的应用，即使在复杂的应用场景下，request的扩展性也非常好。如果你正在写一个API客户端或者网络爬虫，同时对断网情况比较棘手，那么下面所介绍的requests高级技巧可能会帮助你更好的进行程序调试。</p><h2 id="请求钩子">请求钩子</h2><p>应用第三方API时，需要验证应答内容是否合法，requests提供了raise_for_status()方法来判断应答内容的HTTP状态码是不是4xx或者5xx，表明请求产生了客户端或者服务器错误。</p><p>例如：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.github.com/user/repos?page=1'</span><span class="p">)</span><span class="c1"># 判断是否有无错误</span><span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span></code></pre></td></tr></table></div></div><p>每一次请求都调用raise_for_status会非常繁琐，requests非常贴心的提供了一个&rsquo;钩子(hook)&lsquo;接口（通过在请求过程的特定部分指定回调函数）。
下面请看案例代码，通过使用hook来确保每次服务应答后，raise_for_status能被调用。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">assert_status_hook</span><span class="o">=</span><span class="k">lambda</span><span class="n">response</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">:</span><span class="n">response</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">hooks</span><span class="p">[</span><span class="s1">'response'</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">assert_status_hook</span><span class="p">]</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.github.com/user/repos?page=1")</span><span class="o">></span><span class="n">HTTPError</span><span class="p">:</span><span class="mi">401</span><span class="n">Client</span><span class="n">Error</span><span class="p">:</span><span class="n">Unauthorized</span><span class="k">for</span><span class="n">url</span><span class="p">:</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">api</span><span class="o">.</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">user</span><span class="o">/</span><span class="n">repos</span><span class="err">?</span><span class="n">page</span><span class="o">=</span><span class="mi">1</span></code></pre></td></tr></table></div></div><h2 id="设置基链接">设置基链接</h2><p>假设你只使用api.org上的一个api，你可能在每次调用时都要重复编写http协议和域名。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.org/list'</span><span class="p">)</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.org/list/3/item'</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>使用BaseUrlSession可以避免敲下这些重复的内容。
下面看案例代码，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">form</span><span class="n">requests_toolbelt</span><span class="kn">import</span><span class="nn">sessions</span><span class="n">http</span><span class="o">=</span><span class="n">sessions</span><span class="o">.</span><span class="n">BaseUrlSession</span><span class="p">(</span><span class="n">base_url</span><span class="o">=</span><span class="s2">"https://api.org"</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/list"</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"/list/item"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p><strong>！注意requests_toolbelt没有默认包含在requests中的，使用时是需要额外安装的</strong></p><h2 id="设置默认超时">设置默认超时</h2><p>requests文档中推荐在生产环境下设置超时，如果你忘记设置超时，应用程序可能会当掉，尤其是在同步环境下，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://github.com/'</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>但是每次设置超时时间会非常繁琐，偶尔忘记设置超时会非常恼火。<img class="lazyload" src="/svg/loading.small.min.svg" data-sizes="auto" data-srcset="/images/posts/giphy.gif,  1.5x,  2x" data-src="" alt="giphy" title="giphy"/></p><p>使用Transport Adapters可以为所有的HTTP调用设置默认超时时间，当然使用后也是可以通过再定义覆盖默认配置，
下面看案例代码，</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span><span class="lnt">23</span><span class="lnt">24</span><span class="lnt">25</span><span class="lnt">26</span><span class="lnt">27</span><span class="lnt">28</span><span class="lnt">29</span><span class="lnt">30</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span><span class="nn">requests.adapters</span><span class="kn">import</span><span class="n">HTTPAdapter</span><span class="n">DEFAULT_TIMEOUT</span><span class="o">=</span><span class="mi">5</span><span class="k">class</span><span class="nc">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">HTTPAdapter</span><span class="p">):</span><span class="k">def</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="o">=</span><span class="n">DEFAULT_TIMEOUT</span><span class="k">if</span><span class="s2">"timeout"</span><span class="ow">in</span><span class="n">kwargs</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="k">del</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="k">def</span><span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">request</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="n">timeout</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"timeout"</span><span class="p">)</span><span class="k">if</span><span class="n">timeout</span><span class="ow">is</span><span class="bp">None</span><span class="p">:</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">"timeout"</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="k">return</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="c1">#使用</span><span class="kn">import</span><span class="nn">requests</span><span class="n">http</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">adapter</span><span class="o">=</span><span class="n">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"http://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="c1">#使用默认配置</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.weibo.com'</span><span class="p">)</span><span class="c1">#覆盖默认配置</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'https://api.weibo.com'</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code></pre></td></tr></table></div></div><h2 id="失败后的重试">失败后的重试</h2><p>服务器当掉后，网络连接会变得拥塞或者有损，如果想要建立更具鲁棒性的系统，那么必须考虑网络连接失败，以及建立重试策略。
在Http客户端上添加重试策略是非常直接的，我们来创建一个HTTPAdapter，然后在adapter上添加策略</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span><span class="nn">requests.adapter</span><span class="kn">import</span><span class="n">HTTPAdapter</span><span class="kn">from</span><span class="nn">requests.packages.urllib3.util.retry</span><span class="kn">import</span><span class="n">Retry</span><span class="n">retry_strategy</span><span class="o">=</span><span class="n">Retry</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">429</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">502</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">],</span><span class="n">method_whitelist</span><span class="o">=</span><span class="p">[</span><span class="s2">"HEAD"</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">,</span><span class="s2">"OPTIONS"</span><span class="p">]</span><span class="p">)</span><span class="n">adapter</span><span class="o">=</span><span class="n">HTTPAdapter</span><span class="p">(</span><span class="n">max_retries</span><span class="o">=</span><span class="n">retry_strategy</span><span class="p">)</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"http://"</span><span class="p">,</span><span class="n">adapter</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://en.wikipedia.org/w/api.php"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>默认的 Retry 类提供了健全的默认值，但是是高度可配置的，所以这里是我使用的最常见参数的纲要。
其中</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">total</span><span class="o">=</span><span class="mi">3</span></code></pre></td></tr></table></div></div><p>total代表重试的总次数，如果失败的请求或者重定向的次数超过这个数字，客户端将抛出 urllib3.exceptions.Maxretryerror 异常。通常3次重试就足够了。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">413</span><span class="p">,</span><span class="mi">429</span><span class="p">,</span><span class="mi">503</span><span class="p">]</span></code></pre></td></tr></table></div></div><p>要重试的 HTTP 响应代码。 您可能希望对常见的服务器错误(500、502、503、504)进行重试，因为服务器和反向代理并不总是遵循 HTTP 规范。 总是在超出429速率限制的情况下重试，因为默认情况下，urllib 库应该在失败请求时增量地退出。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">method_whitelist</span><span class="o">=</span><span class="p">[</span><span class="s2">"HEAD"</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">,</span><span class="s2">"PUT"</span><span class="p">,</span><span class="s2">"DELETE"</span><span class="p">,</span><span class="s2">"OPTIONS"</span><span class="p">,</span><span class="s2">"TRACE"</span><span class="p">]</span></code></pre></td></tr></table></div></div><p>要重试的 HTTP 方法。 默认情况下，这包括除 POST 以外的所有 HTTP 方法，因为 POST 可能导致新的插入。 修改此参数以包含 POST，因为大多数 i 处理的 API 不返回错误代码并在同一调用中执行插入操作。 如果他们这样做了，您可能应该发布一个 bug 报告。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">backoff_factor</span><span class="o">=</span><span class="mi">0</span></code></pre></td></tr></table></div></div><p>backoff_factor(退避因子)与失败的请求之间休眠的时间有关，其算法如下：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="p">{</span><span class="n">backoff</span><span class="n">factor</span><span class="p">}</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">({</span><span class="n">number</span><span class="n">of</span><span class="n">total</span><span class="n">retries</span><span class="p">}</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span></code></pre></td></tr></table></div></div><p>例如，如果退避因子设置为:
1：连续睡眠：0.5，1，2，4，8，16，32，64，128，256
2：连续睡眠：1，2，4，8，16，32，64，128，256，512
10：连续睡眠：5，10，20，40，80，160，320，640，1280，2560
作为重试策略的合理默认实现，连续睡眠值是呈指数增长的，通过设置退避因子，可以决定每个睡眠乘以多少。这个值默认为0，表示不会设置截断二进制指数退避算法，重试将立即执行。</p><h3 id="结合超时和重试">结合超时和重试</h3><p>由于 HTTPAdapter 具有类比的特性，我们可以像下面这样将重试和超时结合起来:</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">retries</span><span class="o">=</span><span class="n">Retry</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">backoff_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">429</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">502</span><span class="p">,</span><span class="mi">503</span><span class="p">,</span><span class="mi">504</span><span class="p">])</span><span class="n">http</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="s2">"https://"</span><span class="p">,</span><span class="n">TimeoutHTTPAdapter</span><span class="p">(</span><span class="n">max_retries</span><span class="o">=</span><span class="n">retries</span><span class="p">))</span></code></pre></td></tr></table></div></div><h2 id="调试http请求">调试HTTP请求</h2><p>有时候请求会失败，而你却不知道为什么。 记录请求和响应可以帮助您了解故障。 有两种方法可以做到这一点——要么使用内置的调试日志记录设置，要么使用请求钩子。</p><h3 id="打印http头文件">打印HTTP头文件</h3><p>更改大于0的日志记录调试级别将记录响应 HTTP 报头。 这是最简单的选项，但它不允许您查看 HTTP 请求或响应体。 如果您处理的 API 返回一个不适合日志记录或包含二进制内容的大体有效负载，那么它是有用的。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="kn">import</span><span class="nn">http</span><span class="n">http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">HTTPConnection</span><span class="o">.</span><span class="n">debuglevel</span><span class="o">=</span><span class="mi">1</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://www.google.com/"</span><span class="p">)</span><span class="c1"># Output</span><span class="n">send</span><span class="p">:</span><span class="sa">b</span><span class="s1">'GET / HTTP/1.1</span><span class="se">\r\n</span><span class="s1">Host: www.google.com</span><span class="se">\r\n</span><span class="s1">User-Agent: python-requests/2.22.0</span><span class="se">\r\n</span><span class="s1">Accept-Encoding: gzip, deflate</span><span class="se">\r\n</span><span class="s1">Accept: */*</span><span class="se">\r\n</span><span class="s1">Connection: keep-alive</span><span class="se">\r\n\r\n</span><span class="s1">'</span><span class="n">reply</span><span class="p">:</span><span class="s1">'HTTP/1.1 200 OK</span><span class="se">\r\n</span><span class="s1">'</span><span class="n">header</span><span class="p">:</span><span class="n">Date</span><span class="p">:</span><span class="n">Fri</span><span class="p">,</span><span class="mi">28</span><span class="n">Feb</span><span class="mi">2020</span><span class="mi">12</span><span class="p">:</span><span class="mi">13</span><span class="p">:</span><span class="mi">26</span><span class="n">GMT</span><span class="n">header</span><span class="p">:</span><span class="n">Expires</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="n">header</span><span class="p">:</span><span class="n">Cache</span><span class="o">-</span><span class="n">Control</span><span class="p">:</span><span class="n">private</span><span class="p">,</span><span class="nb">max</span><span class="o">-</span><span class="n">age</span><span class="o">=</span><span class="mi">0</span></code></pre></td></tr></table></div></div><h3 id="打印所有">打印所有</h3><p>如果您想记录整个 HTTP 生命周期，包括请求和响应的文本表示，那么您可以使用请求钩子和请求工具自带的转储组件。
在处理基于 REST 的 API 时，我更喜欢这个选项，因为它不会返回非常大的响应。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span><span class="lnt">23</span><span class="lnt">24</span><span class="lnt">25</span><span class="lnt">26</span><span class="lnt">27</span><span class="lnt">28</span><span class="lnt">29</span><span class="lnt">30</span><span class="lnt">31</span><span class="lnt">32</span><span class="lnt">33</span><span class="lnt">34</span><span class="lnt">35</span><span class="lnt">36</span><span class="lnt">37</span><span class="lnt">38</span><span class="lnt">39</span><span class="lnt">40</span><span class="lnt">41</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="kn">from</span><span class="nn">requests_toolbelt.utils</span><span class="kn">import</span><span class="n">dump</span><span class="k">def</span><span class="nf">logging_hook</span><span class="p">(</span><span class="n">response</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span><span class="n">data</span><span class="o">=</span><span class="n">dump</span><span class="o">.</span><span class="n">dump_all</span><span class="p">(</span><span class="n">response</span><span class="p">)</span><span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">'utf-8'</span><span class="p">))</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">hooks</span><span class="p">[</span><span class="s2">"response"</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">logging_hook</span><span class="p">]</span><span class="n">http</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://api.openaq.org/v1/cities"</span><span class="p">,</span><span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s2">"country"</span><span class="p">:</span><span class="s2">"BA"</span><span class="p">})</span><span class="c1"># Output</span><span class="o">&lt;</span><span class="n">GET</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">cities</span><span class="err">?</span><span class="n">country</span><span class="o">=</span><span class="n">BA</span><span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span><span class="o">&lt;</span><span class="n">Host</span><span class="p">:</span><span class="n">api</span><span class="o">.</span><span class="n">openaq</span><span class="o">.</span><span class="n">org</span><span class="o">></span><span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span><span class="mi">200</span><span class="n">OK</span><span class="o">></span><span class="n">Content</span><span class="o">-</span><span class="n">Type</span><span class="p">:</span><span class="n">application</span><span class="o">/</span><span class="n">json</span><span class="p">;</span><span class="n">charset</span><span class="o">=</span><span class="n">utf</span><span class="o">-</span><span class="mi">8</span><span class="o">></span><span class="n">Transfer</span><span class="o">-</span><span class="n">Encoding</span><span class="p">:</span><span class="n">chunked</span><span class="o">></span><span class="n">Connection</span><span class="p">:</span><span class="n">keep</span><span class="o">-</span><span class="n">alive</span><span class="o">></span><span class="p">{</span><span class="s2">"meta"</span><span class="p">:{</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"openaq-api"</span><span class="p">,</span><span class="s2">"license"</span><span class="p">:</span><span class="s2">"CC BY 4.0"</span><span class="p">,</span><span class="s2">"website"</span><span class="p">:</span><span class="s2">"https://docs.openaq.org/"</span><span class="p">,</span><span class="s2">"page"</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s2">"limit"</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span><span class="s2">"found"</span><span class="p">:</span><span class="mi">1</span><span class="p">},</span><span class="s2">"results"</span><span class="p">:[</span><span class="p">{</span><span class="s2">"country"</span><span class="p">:</span><span class="s2">"BA"</span><span class="p">,</span><span class="s2">"name"</span><span class="p">:</span><span class="s2">"Goražde"</span><span class="p">,</span><span class="s2">"city"</span><span class="p">:</span><span class="s2">"Goražde"</span><span class="p">,</span><span class="s2">"count"</span><span class="p">:</span><span class="mi">70797</span><span class="p">,</span><span class="s2">"locations"</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span><span class="p">]</span><span class="p">}</span></code></pre></td></tr></table></div></div><h2 id="测试和模拟请求">测试和模拟请求</h2><p>在开发中使用第三方 API 会引入一个痛点——很难进行单元测试。 为减轻这种痛苦，Sentry 的工程师在开发过程中编写了一个模拟请求的库。</p><blockquote><p>不是将 HTTP 响应发送给服务器 getsentry / responses，而是截取 HTTP 请求，在应答时，测试过程中添加预定义的响应内容。</p></blockquote><p>下面请看案例代码</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt"> 1</span><span class="lnt"> 2</span><span class="lnt"> 3</span><span class="lnt"> 4</span><span class="lnt"> 5</span><span class="lnt"> 6</span><span class="lnt"> 7</span><span class="lnt"> 8</span><span class="lnt"> 9</span><span class="lnt">10</span><span class="lnt">11</span><span class="lnt">12</span><span class="lnt">13</span><span class="lnt">14</span><span class="lnt">15</span><span class="lnt">16</span><span class="lnt">17</span><span class="lnt">18</span><span class="lnt">19</span><span class="lnt">20</span><span class="lnt">21</span><span class="lnt">22</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">unittest</span><span class="kn">import</span><span class="nn">requests</span><span class="kn">import</span><span class="nn">responses</span><span class="k">class</span><span class="nc">TestAPI</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><span class="nd">@responses.activate</span><span class="c1"># intercept HTTP calls within this method</span><span class="k">def</span><span class="nf">test_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="n">response_data</span><span class="o">=</span><span class="p">{</span><span class="s2">"id"</span><span class="p">:</span><span class="s2">"ch_1GH8so2eZvKYlo2CSMeAfRqt"</span><span class="p">,</span><span class="s2">"object"</span><span class="p">:</span><span class="s2">"charge"</span><span class="p">,</span><span class="s2">"customer"</span><span class="p">:</span><span class="p">{</span><span class="s2">"id"</span><span class="p">:</span><span class="s2">"cu_1GGwoc2eZvKYlo2CL2m31GRn"</span><span class="p">,</span><span class="s2">"object"</span><span class="p">:</span><span class="s2">"customer"</span><span class="p">},</span><span class="p">}</span><span class="c1"># mock the Stripe API</span><span class="n">responses</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">GET</span><span class="p">,</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">,</span><span class="n">json</span><span class="o">=</span><span class="n">response_data</span><span class="p">,</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">)</span><span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">(),</span><span class="n">response_data</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>如果发出的 HTTP 请求与模拟响应不匹配，则会抛出 ConnectionError。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span><span class="nc">TestAPI</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><span class="nd">@responses.activate</span><span class="k">def</span><span class="nf">test_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span><span class="n">responses</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">responses</span><span class="o">.</span><span class="n">GET</span><span class="p">,</span><span class="s2">"https://api.stripe.com/v1/charges"</span><span class="p">)</span><span class="n">response</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"https://invalid-request.com"</span><span class="p">)</span></code></pre></td></tr></table></div></div><p>输出：</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span><span class="lnt">6</span><span class="lnt">7</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">:</span><span class="n">Connection</span><span class="n">refused</span><span class="n">by</span><span class="n">Responses</span><span class="o">-</span><span class="n">the</span><span class="n">call</span><span class="n">doesn</span><span class="s1">'t match any registered mock.</span><span class="n">Request</span><span class="p">:</span><span class="o">-</span><span class="n">GET</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">invalid</span><span class="o">-</span><span class="n">request</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">Available</span><span class="n">matches</span><span class="p">:</span><span class="o">-</span><span class="n">GET</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">api</span><span class="o">.</span><span class="n">stripe</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">charges</span></code></pre></td></tr></table></div></div><h2 id="模仿浏览器行为">模仿浏览器行为</h2><p>如果你已经写了足够多的网络爬虫代码，你将会注意到某些网站会根据浏览器或者请求方式返回不同的 HTML内容。 有时这是一种反抓取措施，但通常服务器会进行用户代理嗅探，以找出最适合设备的内容(例如桌面或移动设备)。
如果你想返回与浏览器显示的内容相同的内容，你可以使用 Firefox 或 Chrome 发送的内容覆盖默认的 User-Agent 头请求集。</p><div class="highlight"><div class="chroma"><table class="lntable"><tr><td class="lntd"><pre class="chroma"><code><span class="lnt">1</span><span class="lnt">2</span><span class="lnt">3</span><span class="lnt">4</span><span class="lnt">5</span></code></pre></td><td class="lntd"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span><span class="nn">requests</span><span class="n">http</span><span class="o">=</span><span class="n">requests</span><span class="o">.</span><span class="n">Session</span><span class="p">()</span><span class="n">http</span><span class="o">.</span><span class="n">headers</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">"User-Agent"</span><span class="p">:</span><span class="s2">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0"</span><span class="p">})</span></code></pre></td></tr></table></div></div><hr><p>参考：</p><ul><li><a href="https://hodovi.ch/blog/advanced-usage-python-requests-timeouts-retries-hooks/" target="_blank" rel="noopener noreffer">Advanced usage of Python requests - timeouts, retries, hooks</a></li></ul></description></item></channel></rss>