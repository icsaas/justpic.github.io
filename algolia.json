[{"categories":["database"],"content":"时序数据库在当下产业互联网背景下，在金融、工业等领域得到越来越多的应用，主要面向高并发、海量时序数据等应用场景中。 ","date":"2020-05-07","objectID":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":[],"title":"时序数据库使用总结","uri":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["database"],"content":"大规模时序数据具有特点 占用空间极大 数据总吞吐量大 产生速度快且不间断 \r","date":"2020-05-07","objectID":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:1","tags":[],"title":"时序数据库使用总结","uri":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["database"],"content":"时序数据存储的需求 全时全量 高效写入 紧凑存储 时序数据库与关系型数据库 时序数据管理具有超高性能，超多序列的特点 关系型数据库具有写入受限的缺点 单表列数上限 mysql innodb最大为1017列 单表行数不易过多 小于1000万行 水平、垂直分表；分库 键值数据库可管理海量条时间序列数据，但查询受限：主要包括按时间纬度的查询，按值纬度的查询，多序列的时间对齐查询。 除此之外，时序数据库还有一个优点：由于时序数据库其具有时间相关性，不需要处理关系性数据库下的分布式锁这类比较繁琐的事务。 ","date":"2020-05-07","objectID":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:2","tags":[],"title":"时序数据库使用总结","uri":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["database"],"content":"时序数据库大体上可分为三种： 基于关系数据库的： Timescale,基于PG开发的插件 能够做到： 时序数据自动分区 优化查询计划 定制并行查询 但随着导入时间增加时，其导入效率不断下降 基于键值数据库的： OpenTSDB,KairosDB 这类时序数据库一般基于HBase/Cassandra衍生， 支持时序分区键，定时任务构件索引。但存在压缩不友好，查询不友好的缺点。 \r原生时序数据库： influxdb 基于LSM机制的时序库， 专属文件结构 专属查询优化 特定工业场景下性能会下降 iotdb grafana-adaptor pisa索引 ","date":"2020-05-07","objectID":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:3","tags":[],"title":"时序数据库使用总结","uri":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["database"],"content":"常用时序数据库： iotdb influxdb taosdb timescale kairosdb 经过测试iotdb性能较优 ","date":"2020-05-07","objectID":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:4","tags":[],"title":"时序数据库使用总结","uri":"/posts/2020/05/07/2020-05-07-%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["python"],"content":"2019年以来，图像识别类竞赛也开始集中到口罩和安全帽这两类与健康安全息息相关的场景中，下面主要从这两类场景的一些竞赛资料和比赛流程进行一个简短的介绍， 文章的部分内容被密码保护： \r\r--- DON'T MODIFY THIS LINE ---\r最开始，是通过极市小助手公众号得知极市组织了第一届图像识别类的比赛，比赛内容主要分为口罩识别和安全帽识别，我主要参与的是安全帽识别，在参加极市组织的安全帽比赛过程中，就比赛体验来说， 主要存在以下亮点： 具有代码示例，极大的降低了入门门槛 使用jupyterlab环境进行远程命令操作，继承了较好的用户交互体验 认识了算法交易的一种新的商业模式，极市平台很好的连接了算法生产者和算法消费者，通过商城和开发平台两个不同的模块整合了算法资源，并持续运营。 认识了牛人，知道了Intel Openvino新技术以及常用的目标识别算法，ROI等概念。 但同时感觉可能存在以下改进点： 比赛过程中，参赛人员是不可以接触训练模型的，只能通过网页看到一些数据分析图片，模型调优较为困难，极大地消弱了参与比赛的积极性。 jupyterlab使用时长会消耗积分，关闭实例的同时会连带关闭jupyterlab，感觉jupyterlab本身并不消耗GPU资源，没有必要在关闭训练或者测试实例的时候同时关闭jupyterlab实例。 整个训练测试过程不够直观，需要经过线下编码、线上训练、线上转换模型、线上测试一系列的步骤才能最终得到结果，但中间过程仅通过查询日志才能进行排错，根据官方教程，我本地也建立了一套线下环境，总体感觉数据分析平台还只是一个demo，不能称之为产品，与阿里DOPS或者其他数析平台还有差距，相信极市内部应该还有一套更为成熟的数析平台。建议是否能够研发或者引进算法引擎、类工作流引擎来简化编写代码操作，记得2015年的时候阿里大数据比赛最开始的时候环境也是类似的，后面优化的力度和进度还是挺快的，不光建立了算法资源库，也产生了比较优秀的数析平台。 \r\r 参考 深度学习实现安全帽的检测 基于YOLOV3进行安全帽检测 ai研习社 安全帽检测数据集与与训练模型 安全帽检测数据集 安全帽检测github mfc检测安全帽 cvmart COVID-19:Face Mask Detector with OpenCV,Keras/TensorFlow,and DeepLearning https://github.com/prajnasb/observations ","date":"2020-04-06","objectID":"/posts/2020/04/06/mask-helmet-recognition/:0:0","tags":[],"title":"口罩和安全帽识别","uri":"/posts/2020/04/06/mask-helmet-recognition/"},{"categories":["opencv"],"content":"主要介绍ubuntu 18.04安装OpenCV 4.2.0 ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:0:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"更新系统 $ sudo apt update $ sudo apt upgrade ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:1:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"安装前置依赖包 通用工具 $ sudo apt install build-essential cmake pkg-config unzip yasm git checkinstall 图像I/O库　 $ sudo apt install libjpeg-dev libpng-dev libtiff-dev 视频/音频库-FFMPEG,GSTREAMER,x264等等 $ sudo apt install libavcodec-dev libavformat-dev libswscale-dev libavresample-dev $ sudo apt install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev $ sudo apt install libxvidcore-dev x264 libx264-dev libfaac-dev libmp3lame-dev libtheora-dev $ sudo apt install libfaac-dev libmp3lame-dev libvorbis-dev OpenCore- $ sudo apt install libopencore-amrnb-dev libopencore-amrwb-dev 照相编程接口库　 $ sudo apt-get install libdc1394-22 libdc1394-22-dev libxine2-dev libv4l-dev v4l-utils $ cd /usr/include/linux $ sudo ln -s -f ../libv4l1-videodev.h videodev.h $ cd ~ GTK库－图形用户界面 $ sudo apt-get install libgtk-3-dev python3所使用的库　 $ sudo apt-get install python3-dev python3-pip $ sudo -H pip3 install -U pip numpy $ sudo apt install python3-testresources 用于CPU的C++并行库 $ sudo apt-get install libtbb-dev 用于OpenCV的优化库　 sudo apt-get install libatlas-base-dev gfortran 可选安装　 $ sudo apt-get install libprotobuf-dev protobuf-compiler $ sudo apt-get install libgoogle-glog-dev libgflags-dev $ sudo apt-get install libgphoto2-dev libeigen3-dev libhdf5-dev doxygen ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:2:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"正式安装Opencv 4.2.0步骤 $ cd ~ $ mkdir -p installcv1 $ cd installcv1 $ wget -O opencv.zip https://github.com/opencv/opencv/archive/4.1.1.zip $ wget -O opencv_contrib.zip https://github.com/opencv/opencv_contrib/archive/4.1.1.zip $ unzip opencv.zip $ unzip opencv_contrib.zip $ echo \"Create a virtual environtment for the python binding module\" $ sudo pip install virtualenv virtualenvwrapper $ sudo rm -rf ~/.cache/pip $ echo \"Edit ~/.bashrc\" $ export WORKON_HOME=$HOME/.virtualenvs $ export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 $ source /usr/local/bin/virtualenvwrapper.sh $ mkvirtualenv cv -p python3 $ pip install numpy $ echo \"Procced with the installation\" $ cd opencv-4.2.0 $ mkdir build $ cd build $ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_C_COMPILER=/usr/bin/gcc -D CMAKE_INSTALL_PREFIX=/home/{youraccount}/opencv -D INSTALL_PYTHON_EXAMPLES=ON -D INSTALL_C_EXAMPLES=OFF -D WITH_TBB=ON -D WITH_CUDA=ON -D BUILD_opencv_cudacodec=OFF -D ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 -D WITH_V4L=ON -D WITH_QT=OFF -D WITH_OPENGL=ON -D WITH_GSTREAMER=ON -D OPENCV_GENERATE_PKGCONFIG=ON -D OPENCV_PC_FILE_NAME=opencv.pc -D OPENCV_ENABLE_NONFREE=ON -D OPENCV_PYTHON3_INSTALL_PATH=~/.virtualenvs/cv/lib/python3.6/site-packages -D OPENCV_EXTRA_MODULES_PATH=~/installcv/opencv_contrib-4.2.0/modules -D PYTHON_EXECUTABLE=~/.virtualenvs/cv/bin/python -D BUILD_EXAMPLES=ON　-D WITH_CUDNN=ON -D OPENCV_DNN_CUDA=ON -D CUDA_ARCH_BIN=6.1 -D WITH_INF_ENGINE=ON -D ENABLE_CXX11=ON -D INTEL_CVSDK_DIR=/home/sn0w/intel/openvino_2020.1.023/deployment_tools -D IE_PLUGINS_PATH=/home/sn0w/intel/openvino_2020.1.023/deployment_tools/inference_engine/lib/intel64/ -D INF_ENGINE_RELEASE=2020010000 -D OPENCV_GENERATE_PKGCONFIG=ON -D BUILD_EXAMPLES=ON .. 如果你只是想编译静态库，只需要在Cmake时附加 -D BUILD_SHARED_LIBS=OFF $ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_C_COMPILER=/usr/bin/gcc -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_PYTHON_EXAMPLES=ON -D INSTALL_C_EXAMPLES=OFF -D WITH_TBB=ON -D WITH_CUDA=ON -D BUILD_opencv_cudacodec=OFF -D ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 -D WITH_V4L=ON -D WITH_QT=OFF -D WITH_OPENGL=ON -D WITH_GSTREAMER=ON -D OPENCV_GENERATE_PKGCONFIG=ON -D OPENCV_PC_FILE_NAME=opencv.pc -D OPENCV_ENABLE_NONFREE=ON -D OPENCV_PYTHON3_INSTALL_PATH=~/.virtualenvs/cv/lib/python3.6/site-packages -D OPENCV_EXTRA_MODULES_PATH=~／installcv/opencv_contrib-4.2.0/modules -D PYTHON_EXECUTABLE=~/.virtualenvs/cv/bin/python -D BUILD_EXAMPLES=ON -D BUILD_SHARED_LIBS=OFF .. 如果你不想包括CUDA，只需要设置-D WITH_CUDA=OFF $ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_C_COMPILER=/usr/bin/gcc-6 -D CMAKE_INSTALL_PREFIX=/home/{youraccount}/opencv -D INSTALL_PYTHON_EXAMPLES=ON -D INSTALL_C_EXAMPLES=OFF -D WITH_TBB=ON -D WITH_CUDA=OFF -D BUILD_opencv_cudacodec=OFF -D ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 -D WITH_CUBLAS=1 -D WITH_V4L=ON -D WITH_QT=OFF -D WITH_OPENGL=ON -D WITH_GSTREAMER=ON -D OPENCV_GENERATE_PKGCONFIG=ON -D OPENCV_PC_FILE_NAME=opencv.pc -D OPENCV_ENABLE_NONFREE=ON -D OPENCV_PYTHON3_INSTALL_PATH=~/.virtualenvs/cv/lib/python3.6/site-packages -D OPENCV_EXTRA_MODULES_PATH=~/installcv1/opencv_contrib-4.2.0/modules -D PYTHON_EXECUTABLE=~/.virtualenvs/cv/bin/python -D BUILD_EXAMPLES=ON .. 如果你想使用CUDNN，你必须在Cmake时包含这些标记（正确的设置CUDA_ARCH_BIN的值) -D WITH_CUDNN=ON \\ -D OPENCV_DNN_CUDA=ON \\ -D CUDA_ARCH_BIN=6.1 \\ 在https://developer.nvidia.com/cuda-gpus网站上可以看到自己网卡可兼容的CUDA版本情况． 正式编译前，你必须检查CUDA在Cmake输出时是否启用 -- NVIDIA CUDA: YES (ver 10.0, CUFFT CUBLAS NVCUVID FAST_MATH) -- NVIDIA GPU arch: 30 35 37 50 52 60 61 70 75 -- NVIDIA PTX archs: 正式编译和安装 $ nproc $ make -j8 #！ubuntu 18.04编译过程中出现错误：sudo ln -s /usr/include/eigen3/Eigen /usr/include/Eigen $ sudo make install 配置环境变量 $ sudo /bin/bash -c 'echo \"/usr/local/lib\" \u003e\u003e /etc/ld.so.conf.d/opencv.conf' $ sudo ldconfig $ 如果你想让python的cv包能够在系统环境下使用，必须要下面的复制工作 $ sudo cp -r ~/.virtualenvs/cv/lib/python3.6/site-packages/cv2 /usr/local/lib/python3.6/dist-packages $ export LD_LIBRARY_PATH=/home/{youraccount}/ev_sdk/lib:/home/{youraccount}/opencv/lib:/u","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:3:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"测试安装　 案例程序 //test.cpp #include \u003ciostream\u003e#include \u003cctime\u003e#include \u003ccmath\u003e#include \"bits/time.h\" #include \u003copencv2/core.hpp\u003e#include \u003copencv2/highgui.hpp\u003e#include \u003copencv2/imgproc.hpp\u003e#include \u003copencv2/imgcodecs.hpp\u003e #include \u003copencv2/core/cuda.hpp\u003e#include \u003copencv2/cudaarithm.hpp\u003e#include \u003copencv2/cudaimgproc.hpp\u003e #define TestCUDA true int main() { std::clock_t begin = std::clock(); try { cv::String filename = \"/home/raul/Pictures/Screenshot_20170317_105454.png\"; cv::Mat srcHost = cv::imread(filename, cv::IMREAD_GRAYSCALE); for(int i=0; i\u003c1000; i++) { if(TestCUDA) { cv::cuda::GpuMat dst, src; src.upload(srcHost); //cv::cuda::threshold(src,dst,128.0,255.0, CV_THRESH_BINARY); cv::cuda::bilateralFilter(src,dst,3,1,1); cv::Mat resultHost; dst.download(resultHost); } else { cv::Mat dst; cv::bilateralFilter(srcHost,dst,3,1,1); } } //cv::imshow(\"Result\",resultHost); //cv::waitKey(); } catch(const cv::Exception\u0026 ex) { std::cout \u003c\u003c \"Error: \" \u003c\u003c ex.what() \u003c\u003c std::endl; } std::clock_t end = std::clock(); std::cout \u003c\u003c double(end-begin) / CLOCKS_PER_SEC \u003c\u003c std::endl; } 编译和执行 $ g++ -o test test.cpp `pkg-config opencv --cflags --libs` $ ./test ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:4:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"FAQ 编译过程中如果出现如下错误，说明显卡不支持CUDA的最低要求 CUDA backend for DNN module requires CC 5.3 or higher. Please remove unsupported architectures from CUDA_ARCH_BIN option. ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:5:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["opencv"],"content":"安装或者编译错误　 opencv_contrib-4.1.1/modules/cudaimgproc/src/cuda/bilateral_filter.cu:140: error: (-217:Gpu API call) invalid configuration argument in function ‘bilateral_caller’ cmake项目编译出现undefined reference to `cv::freetype::createFreeType2()　参考 https://medium.com/repro-repo/install-cuda-10-1-and-cudnn-7-5-0-for-pytorch-on-ubuntu-18-04-lts-9b6124c44cc https://gist.github.com/raulqf/f42c718a658cddc16f9df07ecc627be7 ","date":"2020-03-27","objectID":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/:6:0","tags":["linux"],"title":"ubuntu 18.04系统安装OpenCV 4.2.0 ","uri":"/posts/2020/03/27/ubuntu-18.04-install-opencv-4.2.0/"},{"categories":["python"],"content":"作为python中最通用的http工具库之一——requests，具有简洁、直观和全面的特点，一般来说，requests与python中的内置模块urllib3已经逐渐成为程序员处理HTTP请求的首选工具。 得益于requests简洁的API接口，在生产环境下得到了非常普遍的应用，即使在复杂的应用场景下，request的扩展性也非常好。如果你正在写一个API客户端或者网络爬虫，同时对断网情况比较棘手，那么下面所介绍的requests高级技巧可能会帮助你更好的进行程序调试。 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:0:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"请求钩子 应用第三方API时，需要验证应答内容是否合法，requests提供了raise_for_status()方法来判断应答内容的HTTP状态码是不是4xx或者5xx，表明请求产生了客户端或者服务器错误。 例如： response = requests.get('https://api.github.com/user/repos?page=1') # 判断是否有无错误 response.raise_for_status() 每一次请求都调用raise_for_status会非常繁琐，requests非常贴心的提供了一个’钩子(hook)‘接口（通过在请求过程的特定部分指定回调函数）。 下面请看案例代码，通过使用hook来确保每次服务应答后，raise_for_status能被调用。 http = requests.Session() assert_status_hook = lambda response,*args,**kwargs: response.raise_for_status() http.hooks['response'] = [assert_status_hook] http.get('https://api.github.com/user/repos?page=1\") \u003e HTTPError: 401 Client Error: Unauthorized for url: https://api.github.com/user/repos?page=1 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:1:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"设置基链接 假设你只使用api.org上的一个api，你可能在每次调用时都要重复编写http协议和域名。 requests.get('https://api.org/list') requests.get('https://api.org/list/3/item') 使用BaseUrlSession可以避免敲下这些重复的内容。 下面看案例代码， form requests_toolbelt import sessions http = sessions.BaseUrlSession(base_url = \"https://api.org\") http.get(\"/list\") http.get(\"/list/item\") ！注意requests_toolbelt没有默认包含在requests中的，使用时是需要额外安装的 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:2:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"设置默认超时 requests文档中推荐在生产环境下设置超时，如果你忘记设置超时，应用程序可能会当掉，尤其是在同步环境下， requests.get('https://github.com/',timeout=0.001) 但是每次设置超时时间会非常繁琐，偶尔忘记设置超时会非常恼火。 使用Transport Adapters可以为所有的HTTP调用设置默认超时时间，当然使用后也是可以通过再定义覆盖默认配置， 下面看案例代码， from requests.adapters import HTTPAdapter DEFAULT_TIMEOUT = 5 class TimeoutHTTPAdapter(HTTPAdapter): def __init__(self,*args,**kwargs): self.timeout = DEFAULT_TIMEOUT if \"timeout\" in kwargs: self.timeout = kwargs[\"timeout\"] del kwargs[\"timeout\"] super().__init__(*args,**kwargs) def send(self, request,**kwargs): timeout = kwargs.get(\"timeout\") if timeout is None: kwargs[\"timeout\"] = self.timeout return super().send(request,**kwargs) #使用 import requests http = request.Session() adapter = TimeoutHTTPAdapter(timeout=2.5) http.mount(\"https://\",adapter) http.mount(\"http://\",adapter) #使用默认配置 response = http.get('https://api.weibo.com') #覆盖默认配置 response = http.get('https://api.weibo.com',timeout=10) ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:3:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"失败后的重试 服务器当掉后，网络连接会变得拥塞或者有损，如果想要建立更具鲁棒性的系统，那么必须考虑网络连接失败，以及建立重试策略。 在Http客户端上添加重试策略是非常直接的，我们来创建一个HTTPAdapter，然后在adapter上添加策略 from requests.adapter import HTTPAdapter from requests.packages.urllib3.util.retry import Retry retry_strategy = Retry( total = 3, status_forcelist = [429,500,502,503,504], method_whitelist = [\"HEAD\",\"GET\",\"OPTIONS\"] ) adapter = HTTPAdapter(max_retries = retry_strategy) http = requests.Session() http.mount(\"https://\",adapter) http.mount(\"http://\",adapter) response = http.get(\"https://en.wikipedia.org/w/api.php\") 默认的 Retry 类提供了健全的默认值，但是是高度可配置的，所以这里是我使用的最常见参数的纲要。 其中 total=3 total代表重试的总次数，如果失败的请求或者重定向的次数超过这个数字，客户端将抛出 urllib3.exceptions.Maxretryerror 异常。通常3次重试就足够了。 status_forcelist=[413, 429, 503] 要重试的 HTTP 响应代码。 您可能希望对常见的服务器错误(500、502、503、504)进行重试，因为服务器和反向代理并不总是遵循 HTTP 规范。 总是在超出429速率限制的情况下重试，因为默认情况下，urllib 库应该在失败请求时增量地退出。 method_whitelist=[\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"] 要重试的 HTTP 方法。 默认情况下，这包括除 POST 以外的所有 HTTP 方法，因为 POST 可能导致新的插入。 修改此参数以包含 POST，因为大多数 i 处理的 API 不返回错误代码并在同一调用中执行插入操作。 如果他们这样做了，您可能应该发布一个 bug 报告。 backoff_factor=0 backoff_factor(退避因子)与失败的请求之间休眠的时间有关，其算法如下： {backoff factor} * (2 ** ({number of total retries} - 1)) 例如，如果退避因子设置为: 1：连续睡眠：0.5，1，2，4，8，16，32，64，128，256 2：连续睡眠：1，2，4，8，16，32，64，128，256，512 10：连续睡眠：5，10，20，40，80，160，320，640，1280，2560 作为重试策略的合理默认实现，连续睡眠值是呈指数增长的，通过设置退避因子，可以决定每个睡眠乘以多少。这个值默认为0，表示不会设置截断二进制指数退避算法，重试将立即执行。 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:4:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"结合超时和重试 由于 HTTPAdapter 具有类比的特性，我们可以像下面这样将重试和超时结合起来: retries = Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504]) http.mount(\"https://\", TimeoutHTTPAdapter(max_retries=retries)) ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:4:1","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"调试HTTP请求 有时候请求会失败，而你却不知道为什么。 记录请求和响应可以帮助您了解故障。 有两种方法可以做到这一点——要么使用内置的调试日志记录设置，要么使用请求钩子。 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:5:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"打印HTTP头文件 更改大于0的日志记录调试级别将记录响应 HTTP 报头。 这是最简单的选项，但它不允许您查看 HTTP 请求或响应体。 如果您处理的 API 返回一个不适合日志记录或包含二进制内容的大体有效负载，那么它是有用的。 import requests import http http.client.HTTPConnection.debuglevel = 1 requests.get(\"https://www.google.com/\") # Output send: b'GET / HTTP/1.1\\r\\nHost: www.google.com\\r\\nUser-Agent: python-requests/2.22.0\\r\\nAccept-Encoding: gzip, deflate\\r\\nAccept: */*\\r\\nConnection: keep-alive\\r\\n\\r\\n' reply: 'HTTP/1.1 200 OK\\r\\n' header: Date: Fri, 28 Feb 2020 12:13:26 GMT header: Expires: -1 header: Cache-Control: private, max-age=0 ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:5:1","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"打印所有 如果您想记录整个 HTTP 生命周期，包括请求和响应的文本表示，那么您可以使用请求钩子和请求工具自带的转储组件。 在处理基于 REST 的 API 时，我更喜欢这个选项，因为它不会返回非常大的响应。 import requests from requests_toolbelt.utils import dump def logging_hook(response, *args, **kwargs): data = dump.dump_all(response) print(data.decode('utf-8')) http = requests.Session() http.hooks[\"response\"] = [logging_hook] http.get(\"https://api.openaq.org/v1/cities\", params={\"country\": \"BA\"}) # Output \u003c GET /v1/cities?country=BA HTTP/1.1 \u003c Host: api.openaq.org \u003e HTTP/1.1 200 OK \u003e Content-Type: application/json; charset=utf-8 \u003e Transfer-Encoding: chunked \u003e Connection: keep-alive \u003e { \"meta\":{ \"name\":\"openaq-api\", \"license\":\"CC BY 4.0\", \"website\":\"https://docs.openaq.org/\", \"page\":1, \"limit\":100, \"found\":1 }, \"results\":[ { \"country\":\"BA\", \"name\":\"Goražde\", \"city\":\"Goražde\", \"count\":70797, \"locations\":1 } ] } ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:5:2","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"测试和模拟请求 在开发中使用第三方 API 会引入一个痛点——很难进行单元测试。 为减轻这种痛苦，Sentry 的工程师在开发过程中编写了一个模拟请求的库。 不是将 HTTP 响应发送给服务器 getsentry / responses，而是截取 HTTP 请求，在应答时，测试过程中添加预定义的响应内容。 下面请看案例代码 import unittest import requests import responses class TestAPI(unittest.TestCase): @responses.activate # intercept HTTP calls within this method def test_simple(self): response_data = { \"id\": \"ch_1GH8so2eZvKYlo2CSMeAfRqt\", \"object\": \"charge\", \"customer\": {\"id\": \"cu_1GGwoc2eZvKYlo2CL2m31GRn\", \"object\": \"customer\"}, } # mock the Stripe API responses.add( responses.GET, \"https://api.stripe.com/v1/charges\", json=response_data, ) response = requests.get(\"https://api.stripe.com/v1/charges\") self.assertEqual(response.json(), response_data) 如果发出的 HTTP 请求与模拟响应不匹配，则会抛出 ConnectionError。 class TestAPI(unittest.TestCase): @responses.activate def test_simple(self): responses.add(responses.GET, \"https://api.stripe.com/v1/charges\") response = requests.get(\"https://invalid-request.com\") 输出： requests.exceptions.ConnectionError: Connection refused by Responses - the call doesn't match any registered mock. Request: - GET https://invalid-request.com/ Available matches: - GET https://api.stripe.com/v1/charges ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:6:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"模仿浏览器行为 如果你已经写了足够多的网络爬虫代码，你将会注意到某些网站会根据浏览器或者请求方式返回不同的 HTML内容。 有时这是一种反抓取措施，但通常服务器会进行用户代理嗅探，以找出最适合设备的内容(例如桌面或移动设备)。 如果你想返回与浏览器显示的内容相同的内容，你可以使用 Firefox 或 Chrome 发送的内容覆盖默认的 User-Agent 头请求集。 import requests http = requests.Session() http.headers.update({ \"User-Agent\": \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0\" }) 参考： Advanced usage of Python requests - timeouts, retries, hooks ","date":"2020-03-12","objectID":"/posts/2020/03/12/requsts-advance-usage/:7:0","tags":["python","requests"],"title":"requests库中的那些高级用法","uri":"/posts/2020/03/12/requsts-advance-usage/"},{"categories":["python"],"content":"广受各大企业赞助的jupyter团队所开发的jupyter系列产品(主要包括jupyter notebook、jupyterlab和jupyterhub)，在数据科学领域变得越来越火热，依托python强大的语言生态，得益于其良好的扩展性和友好的用户交互，jupyter逐渐成为数据分析可视化的首选开源工具之一，下面将对数据分析实践过程中针对jupyter的调研分析进行小结.如果你正在使用python语言进行相关数据分析，本文所记录的jupyter相关实践可能对你会有所帮助。 文章的部分内容被密码保护： \r\r--- DON'T MODIFY THIS LINE ---\r\r\r 本文将主要从jupyter产品介绍、产品（jupyter notebook、jupyter lab和jupyterhub）的安装试用、jupyter 扩展优化、以及jupyter竞品分析等四大方面对jupyter的实践进行一个简短的介绍和回顾： ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:0:0","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"jupyter产品介绍： 根据jupyter官方网站，jupyter产品主要包括jupyter notebook、jupyter lab和jupyterhub三款产品，根据文章jupyter notebook、jupyterlab与jupyterhub的区别与联系1,三者的联系和区别如下： jupyter notebook提供了一个交互友好的类webIDE环境，但Jupyter Notebook 是传统的单体服务架构模式, 缺少多用户管理和访问认证等方面的功能, 无法直接部署于计算集群上, 难以充分利用和调度计算中心的计算资源 。 jupyter lab提供了单用户管理和认证，没有提供独立的工作空间，与jupyter notebook相比，功能更为丰富。 jupyter hub提供了多用户管理和认证，支持OAuth协议，为用户提供了独立的工作空间，工作内容可以私有不共享。 在了解了jupyter系列产品后，就可以进行产品的安装和使用了。当然你也可以参考这些文章22和33、44、55来快速入门jupyter的使用. ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:1:0","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"产品安装使用 ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:2:0","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"安装 根据以上的产品介绍，可以根据自己的需求选择安装jupyter notebook、jupyter lab还是jupyterhub。具体参考建议如下： 个人本地使用，安装快速方便–jupyter notebook 个人使用，可能会远程操作，需要额外的安装工作–jupyter lab 小型团队使用，可能需要额外的运维工作– jupyter hub 安装jupyter notebook jupyter notebook目前已经包含在Anaconda安装包中，随Anaconda将一同安装，不需要额外的安装操作，如果你想了解更多jupyter notebook安装细节，可以参考文章6和文章7。 安装jupyter lab jupyter lab可以通过pip，conda命令(Anaconda环境)作为jupyter notebook的扩展进行选装。 安装命令如下： pip install jupyterlab #或者 conda install -c conda-forge jupyterlab 使用过程中，jupyterlab的作用更像一个功能强大的webshell，除支持文件上传，命令行等操作外，能够更直观地管理jupyter notebook的其他扩展。 安装jupyterhub jupyterhub的docker化安装步骤如下： #step1.创建共享目录 $mkdir -p $(pwd)/jupyterhub/jupyterhub $mkdir -p $(pwd)/jupyterhub/home #step2.启动镜像 #docker run -p 8000:8000 -d --name jupyterhub -v /opt/jupyterhub/jupyterhub:/srv/jupyterhub -v /opt/jupyterhub/home:/home --restart=always jupyterhub/jupyterhub jupyterhub docker run -p 8000:8000 -d --name jupyterhub -v $(pwd)/jupyterhub/jupyterhub:/srv/jupyterhub -v $(pwd)/jupyterhub/home:/home jupyterhub/jupyterhub jupyterhub #step3.进入到容器内操作 docker exec -it jupyterhub bash chmod -R 777 /home #step4.添加用户和设置密码 useradd jupyterhub passwd jupyterhub #step5.浏览器访问测试 http://{yourip}:8000 !替换yourip为本机ip地址 ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:2:1","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"使用 启动jupyter 启动jupyter notebook jupyter notebook # 更多命令可额外输入--help进行查看 启动jupyter lab jupyter lab # 更多命令可额外输入--help进行查看 excel表格处理 jupyternotebook中使用pandas可以方便的处理excel文件，简单的差集、并集、交集运算使用几句简单的代码即可完成。 数据可视化分析 结合pandas工具包可以非常方便的进行数据的基础分析，使用plot工具包可以完成交互性比较友好的动态数据分析图表。 ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:2:2","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"jupyter扩展 为了提升jupyter的使用体验，目前已经有非常多的jupyter扩展可供使用，其范围除了优化其本身可视化交互体验之外，还涵盖了排版、多语言支持等功能。 文章88介绍了常用的99种jupyter扩展， 文章99中所介绍的扩展主要围绕人工智能（AI）进行展开， 文章1010介绍了提升jupyter使用环境体验的相关实践， 文章1111介绍了扩展jupyter的99种方法， 文章1212介绍了生成pages的方法， 文章1313中通过低代码方式使用jupyter notebook，进一步降低了jupyter的难度、提高了jupyter的交互友好度。 文章1414主要介绍了jupyter notebook的基础架构，如果需要进行进一步应用开发集成，对其基础架构了解是必须的。 pyspark集成 大数据相关技术的发展，jupyter支持与spark进行相关集成 ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:3:0","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"技术架构分析 jupyter 使用了较新的web技术（Websocket等）来保证用户交互的友好性，提供了一种混合的编辑方式, 将程序 代码运行、文字图表编辑等功能糅合在同一电子笔记中, 打破了两者之间的隔离界限.fastpage12介绍了将jupyternotebook内容导出为page，可以直接应用于博客或者出版，进一步提高了jupyter的可扩展性。为了集成和二次开发jupyter，通过文章技术架构分析14中对jupyter的技术架构进行简单的了解，得出如下jupyter架构图， ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:3:1","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":["python"],"content":"jupyter竞品分析 通过搜索，Netflix发布的Polynote15有可能成为jupyter的竞品，除此之外，阿里巴巴、kaggle以及大多数据竞赛平台也开始提供类似jupyter的数据分析平台以方便开发者快速使用。 如果你有更好的想法和建议，欢迎留言。 参考 jupyter notebook、jupyterlab与jupyterhub的区别与联系 ↩︎ 数据科学和机器学习，jupyternotebook入门指南 ↩︎ 快速学习jupyternotebook ↩︎ jupyter notebook数据格式解析 ↩︎ latex数学符号 ↩︎ 十分钟搭建你的jupyternotebook服务器 ↩︎ 使用jupyternotebook进行远程炼丹 ↩︎ 让jupyter更强大的99中武器 ↩︎ Elyra：基于AI技术的JupyterLab实用扩展集 ↩︎ Elevate Your Jupyter Notebook Environment Experience ↩︎ 扩展Jupyter生态系统的99种方法 ↩︎ jupyter生成pages ↩︎ 低代码方式使用jupyter ↩︎ jupyter notebook架构分析 ↩︎ 还有比 Jupyter 更好用的工具 ↩︎ ","date":"2020-03-09","objectID":"/posts/2020/03/09/jupyter-best-practice/:4:0","tags":["python","jupyter","排版","数据分析","调研分析","BI"],"title":"Jupyter最佳实践","uri":"/posts/2020/03/09/jupyter-best-practice/"},{"categories":null,"content":"软件开发原则是一组具体的规则和建议，如果工程师想要编写工整、清晰和可维护的代码，那么他们需要在程序实现过程中应该遵循一些规则和建议。 没有魔杖可以把变量、类和函数的混合物变成完美的代码，但是有一些技巧和提示可以帮助工程师评判是否在做正确的事情。 文章的部分内容被密码保护： \r\r--- DON'T MODIFY THIS LINE ---\r高校人才网 四川的 湖北的 \r\r 让我们来看看这些基本的建议。 下面的一些原则是特定于 python 的，但大多数不是。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:0:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"量两次，切一次(Measure twice and cut once) 如果你只能从这篇文章中学到一个原则且最重要的一个，那么就是这个。 开发人员，架构师和经理人经常因为个人情绪、以及其他问题而难以集中注意力。 就工程师来说，这个原则意味着选择正确的解决方案，选择正确的方法来解决问题，选择正确的工具来解决问题，对建立的解决方案必须充满信心。 选择这里意味着投入一些思考，找到必要的资源，组建合适的团队，思考设计，思考方法，设定任务，控制结果，并为此承担责任。 这就是“活在当下”。 我认为我自己还没有准备好用正确的词汇来描述它。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:1:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"不要重复自己(Don’t Repeat Yourself) 这是一个相当简单但非常有用的原则，它说在不同的地方重复同样的事情是非常糟糕的。 首先，它涉及到进一步支持和修改代码的必要性。 如果某个代码片段在程序中的几个地方被复制，那么很有可能出现两种灾难性的情况: 当对源代码进行哪怕是很小的改动时，您需要在几个地方更改相同的代码。 这需要额外的时间、精力和注意力，而这件事件通常也非常不容易。 第一项紧随第二项。 团队中的其他开发人员可能会意外地错过其中一个更改(只合并了控制系统中的分支) ，并将面对应用程序中随后出现的一系列错误。 这些 bug 可能会让您感到沮丧，因为您已经听说这样的 bug 似乎已经被修复了。 在这方面，有一个建议ーー如果在清单中发现任何代码超过两次，则应以单独的方式来处置。 这是通用做法。 事实上，即使再次遇到重复的bug，您也应该考虑创建一个单独的方法。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:2:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"奥卡姆剃刀(Occam’s Razor) 这是一个非常普遍的想法，它来自于哲学编程。 这个原则得名于奥克姆的英国修道士威廉。 这一原则表明: ”没有必要，不得增加实体”。 在工程学中，这一原则被解释为: 没有必要创建不必要的实体。 因此，首先考虑添加另一个方法 / 类 / 工具 / 流程等的好处不见得总是一个好主意。 毕竟，如果您添加了另一个方法 / 类 / 工具 / 流程等等，除了增加复杂性之外，您没有得到任何其他好处，那还有什么意义呢？ ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:3:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"保持足够简单(Keep It Simple Stupid ) 这是一个与上面非常类似的原则，但它的含义略有不同。 这个原则要求代码必须尽可能简单，不能有复杂的结构，否则会使代码的调试和维护复杂化。 此外，对于另一个程序员来说，理解代码的逻辑将会更加困难，这反过来也将需要额外的时间和精力。 这就是为什么您应该始终尝试使用简单的构造来尽可能多地解决问题，而不需要使用大量的分支、深层嵌套和过度重载的类结构。 通过这样做，你将使自己和同事的生活更加轻松，因为复杂性会产生错误。 记住 Peter Hintiens 说过的话: “简单永远比功能好”。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:4:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"你不会需要它（You Aren’t Gonna Need It ） 这是许多程序员都会遇到的问题。 从项目一开始就希望立即实现所有必要的(有时甚至是不必要的)功能。 也就是说，当开发人员从一开始就将所有可能的方法添加到类中并实现它们时，甚至可能在未来永远不会使用它们。 因此，根据这个建议，首先，只实现您需要的东西，然后，如果必要的话，再扩展相应功能。 这样，您就可以节省调试代码的工作量、时间以及精力，而实际上这些代码却并不需要。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:5:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"前期大设计(Big Design Up Front) 在开始开发功能之前，您应该首先考虑应用程序架构，并将整个系统设计为足够小的细节，然后才按照预定义的计划进行实现。 原则是有存在的权利的，但是最近，它受到了相当多的批评。 这首先与设计和制定过程中的方案陈旧有关。 在这方面，仍然有必要进行后续的修改。 但它也具有不可否认的优点，在正确的设计中，可以大大降低进一步调试和纠错的成本。 此外，这样的信息系统，作为一个规则，更简洁的架构是正确的。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:6:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"避免过早优化(Avoid Premature Optimization) “过早的优化是编程中所有问题(或者至少是大部分问题)的根源” – Donald Knuth 优化是加快程序运行速度，降低系统资源消耗的一个非常正确和必要的过程。 但是每件事都有它自己的时机。 如果在开发的早期阶段进行优化，可能弊大于利。 首先，它与这样一个事实相关，即优化代码的开发需要更多的时间和精力用于开发和支持。 在这种情况下，您通常必须首先检查所选择的开发方法的正确性。 这就是为什么一开始使用一个简单但不是最优的方法更有利可图。 稍后，在估计这种方法会降低应用程序的工作速度时，可以使用一种更快或更少资源密集型的算法。 此外，只要你最初实现了最优的算法，需求就可能改变，代码就会变成垃圾。 因此，没有必要在过早的优化上浪费时间。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:7:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"最小惊奇原则(Principle Of Least Astonishment) 这个原则意味着您的代码应该是直观和明显的，并且在检查代码时不会让其他开发人员感到惊讶。 例如，如果这个方法被称为“ making cookies” ，但是结果是得到了土豆，那么这段代码就是不好的(很明显)。 此外，如果无法避免副作用，应尽量避免副作用，并将副作用记录在案。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:8:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"S.O.L.I.D. “SOLID”实际上是一组面向对象设计原则。 “ SOLID”中的每个字母代表一个原则，它们是: 单一责任（Single responsibility）: 声明每个模块或类应该对软件提供的功能的一个部分负责，并且这个责任应该完全由类封装; 开闭原则（Open-closed): 声明软件实体(类、模块、功能等)应该对扩展开放，但对修改关闭; 李斯科夫替换(Liskov substitution) 声明继承的类应该补充而不是替换基类的行为; 界面隔离(Interface segregation) 声明任何客户端都不应该被迫依赖于它不使用的方法; 依赖反转(Dependency inversion) 程序员应该在接口层而不是在实现层工作 当一起应用时，这些原则可以帮助开发人员创建易于维护和扩展的代码。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:9:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"Demeter定律 该原则的基本思想是在类之间划分职责区域，并将逻辑封装在类、方法或结构中。 可以从这一原则中区分出若干建议: 类或实体应该是独立的 你应该尝试减少不同类之间的连接数量(所谓的coupling 耦合) 关联的类必须在一个 module / package / 目录中(也称为cohesion 凝聚力.） 遵循这些原则，应用程序变得更加灵活、易于理解和易于维护。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:10:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"总结 同胞们，让我们成为伟大的工程师吧！ 让我们考虑一下设计和构建健壮且实现良好的系统，而不是成长中的有机怪物。 列举的原则在本质上是高度相关和联系的。 当然，我没有创造它们，但是一个小小的提醒也不会伤害到我，至少我是健忘的。 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:11:0","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"参考： What Are The Best Software Engineering Principles? 工程效能提升 我的十年 ","date":"2020-03-08","objectID":"/posts/2020/03/08/software-engineering-best-rules/:11:1","tags":["软件工程"],"title":"什么是好的软件工程原则","uri":"/posts/2020/03/08/software-engineering-best-rules/"},{"categories":null,"content":"Java基础知识清单 主要包括面向对象、基础语法、高级进阶三部分 ","date":"2020-03-05","objectID":"/posts/2020/03/05/java-summary-2020/:0:0","tags":["java"],"title":"Java基础知识总结","uri":"/posts/2020/03/05/java-summary-2020/"},{"categories":null,"content":"面向对象 面向对象的三大特征？ 提示\r\r封装、继承、多态\r\r 接口和抽象类的区别？ 提示\r\r抽象类是为了提供继承； 接口是为了提供一种规范、降低耦合，接口比抽象类的抽象层度更高\r\r ","date":"2020-03-05","objectID":"/posts/2020/03/05/java-summary-2020/:0:1","tags":["java"],"title":"Java基础知识总结","uri":"/posts/2020/03/05/java-summary-2020/"},{"categories":null,"content":"基础语法 Java基本数据类型和包装类型有哪些？ 提示\r\r基本类型： boolean,char,int,byte,short,long,float,double 包装器类型： Boolean,Character,Integer,Byte,Short,Long,Float,Double\r\r final，finally，finalize三者的含义和区别？ 提示\r\rfinal：表示不可变，用来修饰类、方法和变量； finally：是异常处理中的关键字，表示处理完异常后最后的执行操作，但又不一定会执行，不会执行的情况如下： 进入try块之前程序发生异常 在try块中调用了System.exit(0)终止了虚拟机的运行 在try块或catch块中程序被中断，比如说死机。 finalize：是Object类中的一个方法，所有的类都有finalize方法，垃圾收集器在调用前会调用finalize方法，做一些内存清理工作。 \r\r String、StringBuilder、StringBuffer三者的区别？ 提示\r\r String:不可变对象，使用在常量以及少量的变量运算环境下。 字符串常量，一旦创建，不可改变。这里的不可改变指字符串对应堆内存，当我们执行字符串的加操作时，实际上是复制被加字符串的内容到新开辟的字符串空间中，原来的作废。 String 是线程安全的，String 类是 final 类，不可以被继承。 String 的长度是不变的，适用于少量的字符串操作。 StringBuffer:可变字符串对象，线程不安全，使用在频繁进行字符串运算的单线程场景下。 字符串变量，长度可变， 线程安全 。适用于多线程下在字符缓冲区进行大量字符串操作 StringBuilder:可变字符串对象，线程安全，应用在频繁进行字符串运算（拼接、替换、删除等）多线程场景下。 字符串变量，长度可变， 线程不安全 。适用于 单线程 下在字符缓冲区进行大量字符串操作 字符串操作在执行速度： StringBuilder \u003e StringBuffer \u003e String\r\r HashMap的底层原理？ 提示\r\rHashMap的数据结构为数组+（链表或红黑树）\r\r ThreadLocal和synchronized的区别 提示\r\rSynchronized牺牲时间 ThreadLocal牺牲空间\r\r volatile关键字的用法和含义 提示\r\r\r\r 内部类的作用 提示\r\r首先Java类的作用是功能内聚，将相近特性的功能内聚到一个类中，例如StringUtil类内聚String相关的功能，DateUtil类内聚Date相关的功能，那么内部类自然也有功能内聚的作用，与一般类不同的是，定义一个内部类通常意味者既要功能内聚，又要对外屏蔽可见性，即不希望外部可见，减少对外暴露的接口，这样从源码结构上来看，需要了解的类信息更少，更简洁。\r\r 为什么不用内部方法，而要用内部类 提示\r\r既然内部类是为了对外屏蔽可见性，那么内部类的功能不能直接用内部方法实现么？ 内部类可以通过内部方法实现，但有的场景更适合用内部类来实现： 1.有一组相近的功能，可以内聚，归属到一个特性，如果都用方法实现，那么原来这个类的方法会很多 2.需要继承或者实现某个接口，此时通过方法就无法做到。\r\r 内部类和静态内部类的区别 提示\r\r从static关键字的一般用法出发很容易理解两者的区别： 1.static方法不能访问非static成员，同理静态内部类也一样。 2.非static方法能访问非static成员，同理静态内部类也一样 3.非静态成员，需要通过类实例去访问，同理访问内部类也一样 4.静态成员，可以通过类而非类实例来访问，同理访问静态内部类也一样。\r\r 何时使用内部类和静态内部类 提示\r\r这个也可以结合static关键字的一般用法出发来考虑： 1.外部其他类需要如何访问内部类？例如是通过外部类的实例访问，还是通过外部类访问。如果通过类访问，那么就使用静态内部类，否则使用内部类。 2.是否需要访问类的非静态成员，如果需要就用内部类，否则就用静态内部类。\r\r 内部类带来的增强能力–使得多重继承变得可能 提示\r\rJava中不支持继承多个类，但是在一个类中可以定义多个内部类，不同的内部类又可以继承不同的类，这样就等于同一个类可以继承多个类。不过这样做跟使用组合也差不多了，都是在内部持有一个新的类，而继承和组合的区别是继承可以继承一个抽象类，而组合不能。\r\r ArrayList和Vector的区别： 提示\r\r从内部实现机制来讲，ArrayList和Vector都是使用数组来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来已被的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。\r\r 同步代码块和同步代码方法的区别： 提示\r\r同步代码块在锁定的方位上可能比同步方法药效，一般来说锁的范围大小和性能是成反比的。同步块可以更加精确的控制锁的作用域（锁的作用域就是从锁被获取到其被释放的时间），同步方法的锁的作用域就是整个方法。静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁。\r\r SynchronizedList和Vector的区别： 提示\r\rSynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无区别。在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。SynchronizedList有一个构造函数可以传入一个Object，如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。 目前为止有两点，如果使用add方法，那么他们的扩容机制不一样；SynchronizedList可以指定锁定的对象。 SYnchronizedList中实现的类并没有都使用synchronzied同步代码块。其中有listIiterator和listIterator(int index)并没有做同步处理，但是Vector却对该方法加了方法锁，在使用SynchronizedList进行遍历的时候要手动加锁。 将ArrayList转成SynchronizedList，如果我们想把LinkedList变成线程安全的，或者说我想要方便在中间插入和删除的同步的链表，可以将已有的LinkedList之间转成SynchronizedList，不用改变它的底层数据结构，Vector无法做到这一点，他的底层架构是使用数组实现的，这个是无法更改的。\r\r HashMap/HashTable/ConcurrentHashMap区别： 提示\r\rHashTable：同步，key和value都不允许出现null值。 HashMap:非同步，null可以作为键且只能出现一次，可以有一个或多个键所对应的值为null。 ConcurrentHashMap: ConcurrentHashMap和HashMap的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别，ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。 ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制。所以ConcurrentHashMap是线程安全的，HashMap线程不安全。\r\r ","date":"2020-03-05","objectID":"/posts/2020/03/05/java-summary-2020/:0:2","tags":["java"],"title":"Java基础知识总结","uri":"/posts/2020/03/05/java-summary-2020/"},{"categories":null,"content":"高级进阶 代理 JDK和CGLib动态代理实现和区别？ 提示\r\r静态代理： public interface HelloService{ public void say(); } public class HelloServiceImpl implements HelloService{ @Override public void say() { System.out.println(\"Hello World\"); } } public class HelloServiceProxy implements HelloService{ private HelloService target; public HelloServiceProxy(HelloService target){ this.target = target; } @override public void say(){ System.out.println(\"记录日志\"); target.say(); System.out.println(\"清理数据\"); } } public class Main{ @Test public void testProxy(){ HelloService target = new HelloServiceImpl(); HelloServiceProxy proxy = new HelloServiceProxy(target); proxy.say(); } } JDK动态代理：面向接口的代理模式，只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理，cglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。Spring中通过Java的反射机制生产被代理接口的新的匿名实现类，重写其中AOP的增强方法，具体操作步骤如下： 通过InvocationHandler接口创建自己的调用处理器 通过Proxy类指定ClassLoader对象和一组interface来创建动态代理 通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数 CGLib动态代理：利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 \r\r JVM JVM运行时数据区包括那些？ 提示\r\r 方法区 虚拟机栈 本地方法栈 堆 程序计数器 \r\r 类的生命周期包括哪几个阶段？ 提示\r\r 加载 验证 准备 解析 初始化 使用 卸载 \r\r 垃圾回收 提示\r\rCMS收集器：老年代收集器， 一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。 CMS收集器就非常符合这类应用的需求。 CMS收集器是基于标记-清除算法实现的，他的运作过程相对于其他收集器来说复杂一些： 包括： 1.初始标记 2.并发标记 3.重新标记 4.并发清除 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”，初始标记仅仅知识标记以下GCRoots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾手机线程一起并发运行；而重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，多以这个阶段也是可以与用户线程同时并发的。 由于整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 CMS（并发低停顿收集器） CMS三个明显的缺点： 1.CMS收集器对处理器资源非常敏感 2.CMS收集器无法处理“浮动垃圾\"，有可能出现”Concurrent Mobile failure\"失败而导致另一次完全“Stop The World”的FullGC的产生。 3.CMS是一款基于“标记-清除”算法实现的收集器，会产生大量的空间碎片。 G1收集器： 收集器面向局部收集的设计四路和基于Region的内存布局形式， Java9发布之后，G1宣告取代Parallel Scavenge和ParallelOld组合，称为服务端模式下的默认垃圾收集器， G1垃圾回收时，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。 G1开创的基于Region的堆内存布局是他能够实现这个目标的关键。虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每个Region都可以根据需要，扮演新生代的Eden空间，Survior空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间，熬过多次手机的就对象都能获取很好的手机效果。 G1之所以能建立可预测的停顿时间模型，是因为他将Region作为单词回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾手机。 优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来 ， G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现，运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前出发下一次收集 。 用户运行过程中，G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。 小内存应用上，CMS的表现大概率优于G1 大内存应用上，G1则大多能发挥其优势 Java1.7之前运行时常量池逻辑包含字符串常量池，存放在方法区，从此hotspot虚拟机对方法区的实现为永久代 Java1.7中，字符串常量池被从方法去拿到了堆区，这里没有提到运行时常量区，也就是说字符串常量池被单独拿到堆，运行时常量池剩下的东西还在方法区，也就是hotspot中的永久代。 Java1.8中hostspot移除了永久代用原空间取而代之，这时候字符串常量池还在堆，运行时常量池还在方法去，只不过方法区的实现从永久代变成了元空间。 \r\r Spring SpringMVC工作原理： 提示\r\r1.客户端发送请求，直接请求到DispatcherServlet 2.DispatcherServlet根据请求信息调用HandlerMapping,解析请求对应的Handler 3.解析到对应的Handler（也就是我们平常说的Controller控制器） 4.HandlerAdapter会根据Handler来调用真正的处理器来处理请求和执行相对应的业务逻辑 5.处理器处理完业务后，会返回一个ModelandView对象，Model是返回的数据对象，View是逻辑上的View. 6.ViewResolver会根据逻辑View去查找实际的View。 7.DispatcherServlet把返回的Model传给View（视图渲染） 8.把View返回给请求者\r\r Spring框架中用到了哪些设计模式？ 提示\r\r 工厂设计模式： BeanFActory用来创建对象的实例 代理设计模式： AOP和Remoting中被用的比较多。 单例设计模式： 在spring配置文件中定义的bean默认为单例模式 模板方法模式 包装器设计模式 观察者模式 适配器模式 \r\r 自动装配模式的区别： 提示\r\rspring框架中共有5种自动装配 1.no：这是Spring框架的默认设置 2.byName:该选项可以根据bean定义中用标签明确的设置依赖关系，当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错 3.byType:该选项可以根据bean类型设置依赖关系。当像一个bean中自动装配一个属性时，容器将根据bean的类型自动在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 4.constructor:构造器的自动装配和byType模式类似，但是仅仅适用于与构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 5.autodetect:该模式自动探测使用构造器自动装配或者byType自动装配。首先，会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到响应的构造器或者是无参构造器，容器就会自动选择byType的自动装配方式。 @Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring","date":"2020-03-05","objectID":"/posts/2020/03/05/java-summary-2020/:0:3","tags":["java"],"title":"Java基础知识总结","uri":"/posts/2020/03/05/java-summary-2020/"},{"categories":null,"content":"Markdown是一种轻量级标记语言。你不需要关心标题多大字号，段前距多少，列表缩进几格，只要在纯文本前后增加一些标记符号（例如 # - * \u003e)，就能轻松写出工整精美的文章。与富文本编辑器（例如Word）是通过点击图形化的功能按钮来实现排版，而Markdown则是通过标记字符去赋予文字不同格式。易读易写（easy-to-read and easy-to-write),让任何与文字打交道的人专注于写作，不用操心排版，这一点类似vi编辑器功能。 本文主要从Markdown主要特点、入门语法、写作结构大纲、应用场景四个方面对Markdown写作指南进行详细介绍。 ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:0:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"Markdown 主要特点 Markdown主要有以下三大特点： 特点1. 格式统一 同一份Word文档，在 不同的设备：Windows、macOS、Android、iOS 不同的版本：旧版Word、新版Word 不同的软件：Microsoft Office、WPS 可能显示不一样的效果。而Markdown可以Write once,export everywhere。不管在电脑上，还是手机上，用Markdwon写出来的文章都能带来舒适、统一、美好的阅读体验。 特点2. 向外兼容 可以导出PDF、Word、HTML、图片等格式分享给没有安装Markdown编辑器的人，强烈推荐使用pandoc工具进行markdown文档的转换。 特点3. 直接支持html,css Markdown是直接支持在markdown文档中使用html和css语言的： 语法： \u003ca href=\"#jump_1\"\u003e来个页内跳转\u003c/a\u003e，跳转到文未的：`\u003ca id=\"jump_1\"\u003e我是页内跳转到的位置\u003c/a\u003e` ,对应：`id=\"jump_1\"` \u003cspan style=\"color: #5bdaed; \"\u003e先给点颜色你看看\u003c/span\u003e \u003cspan style=\"color: #AE87FA; \"\u003e再给点颜色你看看\u003c/span\u003e \u003cspan style=\"font-size:1.3em;\"\u003e试试改变字体大小\u003c/span\u003e \u003cspan style=\"font-size:1.3em;font-weight: bold;\"\u003e改变字体大小，再来个粗体又如何？\u003c/span\u003e \u003cp style=\"text-align:center\"\u003e 试试内容居中 \u003c/p\u003e \u003cp style=\"text-align:right\"\u003e 那内容居右呢？ \u003c/p\u003e \u003cp style=\"text-align:center;color:#1e819e;font-size:1.3em;font-weight: bold;\"\u003e 来个综合的试试 \u003cbr/\u003e 第二行 \u003c/p\u003e *** \u003ca id=\"jump_1\"\u003e我是页内跳转到的位置\u003c/a\u003e 预览效果： 来个页内跳转，跳转到文未的：\u003ca id=\"jump_1\"\u003e我是页内跳转到的位置\u003c/a\u003e ,对应：id=\"jump_1\" 先给点颜色你看看 再给点颜色你看看 试试改变字体大小 改变字体大小，再来个粗体又如何？ 试试内容居中 那内容居右呢？ 来个综合的试试 第二行 我是页内跳转到的位置 ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:1:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"Markdown入门语法 1.标题、列表、引用 标记符号 标记结果 # + 空格 + 文本 一级标题 ##+空格+文本 二级标题 ###+空格+文本 三级标题 -+空格+文本 无序列表 1+.+空格+文本 有序列表 \u003e+空格+文本 引用 标题 支持6种大小的标题，分别对应#,##,###,####,#####,######，和样式文件中的h1,...,h6如： ##### H5 ###### H6 #### 行内代码 列表 无序列表 建议使用-作为无须列表，型号*可能和加粗和斜体符号产生混淆，加号+不流行。 有序列表 语法一（手动排序）：1+.+空格+文本 1. 斜月沉沉藏海雾，碣石潇湘无限路。 2. 不知乘月几人归，落月摇情满江树。 3. 春江潮水连海平，海上明月共潮生。 语法二（自动排序） 对于比较长的、可能会修改的列表（尤其是很长的嵌套列表），请使用懒人编号法。纵使有新的列表项插队,把序号弄乱了也没关系，Markdown编辑器自动会对序号进行纠错。 语法说明： 1. Foo. 1. Bar. 1. Foofoo. 1. Barbar. 1. Gargar 1. Baz. 预览效果： Foo. Bar. Foofoo. Barbar. Gargar Baz. 嵌套列表 缩进2~4个空格或一个Tab（推荐），可以嵌套列表 示例一 1. 不知乘月几人归，落月摇情满江树。 - 与君吟弄风月，端不负平生。 - 对秋深，离恨苦，数夜满庭风雨。 - 五月畬田收火米，三更津吏报潮鸡。 2. 人姝丽，粉香吹下，夜寒风细。 - 弓弦抱汉月，马足践胡尘。 - 寒月悲笳，万里西风瀚海沙。 - 东堂坐见山，云风相吹嘘。 预览效果： 不知乘月几人归，落月摇情满江树。 与君吟弄风月，端不负平生。 对秋深，离恨苦，数夜满庭风雨。 五月畬田收火米，三更津吏报潮鸡。 人姝丽，粉香吹下，夜寒风细。 弓弦抱汉月，马足践胡尘。 寒月悲笳，万里西风瀚海沙。 东堂坐见山，云风相吹嘘。 引用 在每一行使用\u003e符号，包括换行的句子 2.特殊说明的文字 标记符号 标记结果 **+加粗+** 加粗 *+斜体+* 斜体 ~~+删除线+~~ 删除线 3.任务列表 Markdown支持任务列表 语法： - [ ] 纯牛奶 - [x] 西瓜 - [ ] 鸡蛋 - [ ] 保鲜膜 - [ ] 猪肉 预览效果： 纯牛奶 西瓜 鸡蛋 保鲜膜 猪肉 4.表格 语法： |左对齐|居中对齐|右对齐| |:---|:---:|----:| |**加粗**|[插入连接]（https://)|5.7| |`换行`\u003cbr/\u003e下一行|![插入图片](ht图片上：//）|10.4| 预览效果： 左对齐 居中对齐 右对齐 加粗 [插入连接]（https://) 5.7 换行下一行 ![插入图片](ht图片上：//） 10.4 5.代码 行内代码 用两个重音符`（backtick，在Tab键上方)包裹 `Markdown`是一种轻量级标记语言 预览 Markdown是一种轻量级标记语言 重音符前后空一格 - 推荐：使用键盘快捷键 `Ctrl+D` 可以将当前网页保存为书签。 - 反对：使用键盘快捷键`Ctrl+D`可以将当前网页保存为书签。 - 推荐：使用键盘快捷键 `Ctrl+D` 可以将当前网页保存为书签。 - 反对：使用键盘快捷键`Ctrl+D`可以将当前网页保存为书签。 代码块 将三个重音符`置于代码块的首行和末行 print \"Hello,python!\" 注：markdown对代码块的语法是开始和结束行都要添加：```,其中 ` 为windows键盘左上角那个。 如果要精确指定语言（如：java,cpp,css,xml,javascript,python,php,go,kotlin,lua,objectivec等等）时，在头部直接指定，如：```javascript，如下： ```javascript function showSnackbar() { var $snackbar = $('#snackbar'); $snackbar.addClass('show'); setTimeout(() =\u003e { $snackbar.removeClass('show'); }, 3000); } ``` 6.强制换行 在行末使用空格（两个以上）+换行(Enter) 预览效果： `enticing` - Her neck was short but rounded and her arms plump and enticin 他的脖子短，但浑圆可爱；两臂丰腴，也很动人。by《飘》 - This was enticing to Wozniak,even more than any prospect of getting rich. 这句话对沃兹尼亚克的诱惑太大了，比变成富人的诱惑还要大。by《乔布斯传》 7.外链的超链接 试试外链的超链接：我是外链的超链接,markdown对链接的语法为：\\[\\](),如：\\[我是外链的超链接\\](http://blog.qikqiak.com) 8.页内的超链接 试试页内的超链接：我是页内的超链接，注：你先要在要跳转的到地方放置一个类似：\u003ca id=\"jump_1\"\u003e任意内容\u003c/a\u003e的锚点。由id=\"jump_1\" 来匹配。 9.分隔线 语法： *** 预览效果： 10.符号说明 Markdown针对特殊符号具有转义定义，具体解释如下表： 符号 说明 对应编码 \u0026 AND 符号 \u0026 amp; \u003c 小于 \u0026 lt; 空格 \u0026 nbsp; ¿ 倒问号 \u0026 iquest; ? 问号 \u0026 quest; « 左书名号 \u0026 laquo; » 右书名号 \u0026 raquo; “ 引号 \u0026 quot; ‘ 左单引号 \u0026 lsquo; ’ 右单引号 \u0026 rsquo; “ 左双引号 \u0026 ldquo; ” 右双引号 \u0026 rdquo ¶ 段落符号 \u0026 para; § 章节符 \u0026 sect; × 乘号 \u0026 times; ÷ 除号 \u0026 divide; ± 加减号 \u0026 plusmn; ƒ function \u0026 fnof; √ 根号 \u0026 radic; ∞ 无穷大 \u0026 infin; ° 度 \u0026 deg; ≠ 不等号 \u0026 ne; ≡ 恒等于 \u0026 equiv; ≤ 小于等于 \u0026 le; ≥ 大于等于 \u0026 ge; ⊥ 垂直符号 \u0026 perp; ← 左箭头 \u0026 larr; → 右箭头 \u0026 rarr; ↑ 上箭头 \u0026 uarr; ↓ 下箭头 \u0026 darr; ↔ 水平箭头 \u0026 harr; ↕ 竖直箭头 \u0026 varr; ⇐ 双线左箭头 \u0026 lArr; ⇒ 双线右箭头 \u0026 rArr; ⇑ 双线上箭头 \u0026 uArr; ⇓ 双线上箭头 \u0026 dArr; ⇔ 双线水平双箭头 \u0026 hArr; ⇕ 双线竖直箭头 \u0026 vArr; ♠ 黑桃 \u0026 spades; ♥ 红桃 \u0026 hearts; ♣ 梅花 \u0026 clubs; ♦ 方块 \u0026 diams; © 版权 \u0026 copy; ® 注册商标 \u0026 reg; ™ 商标 \u0026 trade; ¥ 人民币 \u0026 yen; € 欧元 \u0026 euro; ¢ 美分 \u0026 cent; £ 英磅 \u0026 pound; ⊕ \u0026 oplus; ½ 二分之一 \u0026 frac12; ¼ 四分之一 \u0026 frac14; ‰ 千分符号 \u0026 permil; ∴ 所以 \u0026 there4; π 圆周率 \u0026 pi; ¹ 上标1 \u0026 sup1; α alpha \u0026 alpha; β beta \u0026 beta; γ gamma \u0026 gamma; δ delta \u0026 delta; θ theta \u0026 theta; λ lambda \u0026 lambda; σ sigma \u0026 sigma; τ tau \u0026 tau; ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:2:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"写作结构大纲 一般按照如下结构参照Word文档结构进行markdown文档的大纲编写。 ### 标题 #### 层级 # 一级标题：文章的标题 ## 二级标题：文章主要部分的大标题 ### 三级标题：二级标题下面一级的小标题 虽然Markdown最大支持######六级标题，为了保持层级的简单，防止出现过于复杂的章节，请谨慎使用四级标题（除非是长文章）。如果三级标题下有并列性的内容，可以使用加粗、有序列表或无序列表代表末级标题。 ### 三级标题 **四级标题A** - 论据1（五级标题） - 细分论据 1(六级标题) - 细分论据 2（六级标题) - 细分论据 3(六级标题) - 论据2 - 论据3 **四级标题B** 1. 论据 2. 论据 3. 论据 **四级标题C** - 论据1 - 论据2 - 论据3 ---- ### 三级标题（适用于长文章） #### 四级标题A #### 四级标题B #### 四级标题C 文档标题拟定要点 标题要简短，结尾不带标点符号。 （源码上）标题前后空一行（段前距和段后距）。 大标题和小标题之间要有内容过度（引出或概括下文）。 示例： # Title 开门见山地告诉读者这篇文章讲什么？ 一级标题作为文章的（页面）标题（H），并且尽可能和文件名称保持一致。如果文章很长，使用[TOC]生成目录。 ## what 先定义问题是什么?... 正文从二级标题开始 ## Why 为什么会出现这样的问题?... ## How 下一步该怎么办?... ## See also 文末别忘了贴上参考连接。 * https://link-to-more-info ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:3:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"Markdown应用场景 6大应用场景 1.公众号排版 Markdown Nice：让微信排版变 Nice，支持自定义主题 CSS。 可能吧公众号 Style 一键转换器：老司机禅叔出品。 md:自用微信公众号排版 2.博客 3.知乎专栏 4.幻灯片 5.专业报告 6.笔记 ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:4:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"Markdown推荐编辑器 操作系统 Markdown编辑器 windows typora android 纯纯写作 macos/ios Ulysses 参考 Markdown 完全入门（上） Markdown 完全入门（下） 为知笔记 Markdown 新手指南 Markdown 合集 - 少数派 Google Markdown 书写风格指南 Markdown Style Guide by Google Typora 完全使用详解 - liquid617 用markdown可以做什么 markdown styles tech-writing-course hugo使用 关联阅读 markdown写作指南 - justpic ","date":"2020-03-04","objectID":"/posts/2020/03/04/markdown-writing-rules/:5:0","tags":["设计","排版","Markdwon"],"title":"Markdown写作指南","uri":"/posts/2020/03/04/markdown-writing-rules/"},{"categories":null,"content":"本文从低代码发展历史、 相关领域发展情况、以及具体的实现三个方面对低代码的前世今生进行探索。 ","date":"2020-03-02","objectID":"/posts/2020/03/02/lowcode-thoughts/:0:0","tags":["低代码","BPM","工作流"],"title":"浅谈低代码开发","uri":"/posts/2020/03/02/lowcode-thoughts/"},{"categories":null,"content":"低代码发展历史 技术可能是一个革命自我的过程 低代码开发平台的术语虽然2014年才被Forrester Research正式提出，但最早的产品雏形可追溯到2001年所建立的OutSystems中。 低代码出现的时机和原因 软件定义概念的兴起（Software define anything） 高效协同工作的要求 减低信息化活动的技术门槛，让更多的人参与到信息化活动中来，屏蔽复杂的软件设计、编码、测试等比较专业的软件工程过程，使编程工作更好承接业务本身，敏捷精益化。 政策推动的需要 软件产品的迭代进化 技术自我革命 低代码市场发展情况 根据2018年以来的投融资情况，低代码开发产品市场主要集中在OutSystems、Mendix、搭搭云、奥哲网络、轻流、magic、黑帕云、ClickPaas和数式科技，其中部分初创企业最高已获得亿级美元融资，成功跻身独角兽。 低代码热度和趋势 为了更直观地体会低代码的热度，运用百度指数、头条指数、Google Trends等工具查看低代码的热度和趋势。 百度指数上对低代码的搜索情况如下： 图中显示在今年3月份低代码一词热度最高，获得越来越多的关注。 Google Trends上对lowcode、DDD、DSL、BPM的搜索情况如图： 对于低代码（lowcode），google trends并没有显示其获得特别多的关注和热度，但其相关技术：cloud与DSL呈现强烈的负相关关系 ","date":"2020-03-02","objectID":"/posts/2020/03/02/lowcode-thoughts/:1:0","tags":["低代码","BPM","工作流"],"title":"浅谈低代码开发","uri":"/posts/2020/03/02/lowcode-thoughts/"},{"categories":null,"content":"相关领域发展情况 低代码概念作为高度集成的企业信息化解决方案和产品，其相关领域可大致分为OA协同办公、人工智能、中台技术、云开发四大部分。 OA协同办公软件 办公自动化（OA）软件发展历史可追溯到office办公软件，随着Web技术的发展，通过网络技术高度集成相关软件，提高了办公软件的自动化程度。 随着低代码技术的快速发展，OA协同办公软件将迎来重大升级，OA协同办公软件将集成业务建模和仿真这一特性，为业务信息化落地提速增效。 人工智能 人工智能的加持，快速为业务链赋能：人脸识别、自然语言技术作为末端替代人工操作进一步提高工作效率。 数据分析可以进一步分析流程相关时间序列相关数据，迭代优化相关业务。 中台技术的发展 中台技术提供更为灵活的API管理和应用。 云开发环境。 云原生技术的发展将灵活高效地承载低代码业务开发模式。 ","date":"2020-03-02","objectID":"/posts/2020/03/02/lowcode-thoughts/:2:0","tags":["低代码","BPM","工作流"],"title":"浅谈低代码开发","uri":"/posts/2020/03/02/lowcode-thoughts/"},{"categories":null,"content":"具体实现 从低代码说开去,低代码、中台、RPA、人工智能这些概念词更像是为了迎合市场准备的营销素材，从技术实现角度，可能更为关注低代码实现的技术实现细节。 技术实现要点 低代码的技术实现要点主要可以分为云原生、Devops、BPM、DSL、前端可视化等方面。 云原生 云原生为低代码提供基础的软件实施工具，软件云化不仅可以统一管理应用，也提高了基础资源的利用率。 Devops Devops有效为低代码提供持续有效的软件产品构建流程，一方面是软件工程理论的实践，好的DevOps是一套有效运营流程规范。 BPM BPM技术的发展与协同办公软件开发技术发展紧密，activiti、camunda、flowable技术作为开源工作流引擎可以作为业务建模的参考实现。 类BPM技术：数据分析/算法引擎 DSL DSL不仅存在于后台开发技术，而且在前端技术领域也得到越来越多的应用，构建一个好的类型系统可以有效解决复杂业务建模。 前端可视化 前端可视化与用户交互紧密联系，友好的可视化交互操作对低代码的推广使用非常重要。 参考 DSL: 选择DSL实现的方式 TypeScript JSX syntax as a typed DSL DSL.ts DDD: https://github.com/madawei2699/ddd_parklot 低代码： 探路中台、RPA、低代码引领企业级IT服务未来式 https://github.com/phodal/lowcode.git 现代Web开发与未来 云研发 2020年边缘计算为什么会火 麻省理工选出的全球十大突破性技术 大中台模式下如何构建复杂业务核心状态机组件 深入typescript类型系统（二）：泛型和类型元编程 builder模式是一个有限状态机 无代码和低代码会抢走程序员的工作吗 CI/CD: https://www.stackbit.com/ wakatime ","date":"2020-03-02","objectID":"/posts/2020/03/02/lowcode-thoughts/:3:0","tags":["低代码","BPM","工作流"],"title":"浅谈低代码开发","uri":"/posts/2020/03/02/lowcode-thoughts/"},{"categories":["Web开发"],"content":"APIJSON实践 ","date":"2019-10-27","objectID":"/posts/2019/10/27/apijson-exercise/:0:0","tags":["DSL"],"title":"APIJSON实践","uri":"/posts/2019/10/27/apijson-exercise/"},{"categories":["Web开发"],"content":"获取特定对象 ","date":"2019-10-27","objectID":"/posts/2019/10/27/apijson-exercise/:1:0","tags":["DSL"],"title":"APIJSON实践","uri":"/posts/2019/10/27/apijson-exercise/"},{"categories":["Web开发"],"content":"指定数据库服务器和schema进行查询： http://localhost:8088/get/{\"Test\":{\"ID_\":5},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} ","date":"2019-10-27","objectID":"/posts/2019/10/27/apijson-exercise/:1:1","tags":["DSL"],"title":"APIJSON实践","uri":"/posts/2019/10/27/apijson-exercise/"},{"categories":["Web开发"],"content":"获取列表： [返回特定字段] http://localhost:8088/get/{\"[]\":{\"count\":100,\"Test\":{\"@column\":\"USER_ID,TM_ID\"}},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} [返回全部字段列表] http://localhost:8088/get/{\"[]\":{\"count\":100,\"Test\":{\"@column\":\"\"}},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} [分页] http://localhost:8088/get/{\"[]\":{\"count\":100,\"page\":0,\"Test\":{\"@column\":\"\"}},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} [特定字段条件查询] http://localhost:8088/get/{\"Test\":{\"ID_\":5},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} ​ [连续范围] http://localhost:8088/get/{\"Test\":{\"END_TIME%\":\"2018,2019\"},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} ！以上链接直接浏览器请求出错 [时间范围] http://localhost:8088/get/{\"[]\":{\"count\":100,\"Test\":{\"END_TIME{}\":\"\u003c=2019,\u003e=2018\"}},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} [模糊匹配] http://localhost:8088/get/{\"[]\":{\"count\":100,\"Test\":{\"END_TIME$\":\"%2019%\"}},\"@schema\":\"sxb\",\"@database\":\"MYSQL\"} 详细的功能符号介绍： \"key[]\":{} // 查询数组 \"key{}\":[1,2,3] // 匹配选项范围 \"key{}\":\"\u003c=10;length(key)\u003e1...\" // 匹配条件范围 \"key()\":\"function(arg0,arg1...)\" // 远程调用函数 \"key@\":\"key0/key1.../targetKey\" // 引用赋值 \"key$\":\"%abc%\" // 模糊搜索 \"key~\":\"^[0-9]+$\" // 正则匹配 \"key%\":\"2018-01-01,2018-10-01\" // 连续范围 \"key+\":[1] // 增加/扩展 \"key-\":888.88 // 减少/去除 \"name:alias\" // 新建别名 \"@combine\":\"name~,tag~\" // 条件组合 \"@column\":\"id,sex,name\" // 返回字段 \"@group\":\"userId\" // 分组方式 \"@having\":\"max(id)\u003e=100\" // 聚合函数 \"@order\":\"date-,name+\" // 排序方式 \"@schema\":\"sys\" // 集合空间 \"@database\":\"POSTGRESQL\" // 跨数据库 \"@explain\":true // 性能分析 \"@role\":\"LOGIN\" // 访问角色 详细功能符说明可见通用文档 ","date":"2019-10-27","objectID":"/posts/2019/10/27/apijson-exercise/:1:2","tags":["DSL"],"title":"APIJSON实践","uri":"/posts/2019/10/27/apijson-exercise/"},{"categories":["default"],"content":"技术应用：路由转发和反向代理","date":"2019-10-15","objectID":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/","tags":["network"],"title":"路由转发和反向代理的应用","uri":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["default"],"content":"路由转发和反向代理的应用 ","date":"2019-10-15","objectID":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/:0:0","tags":["network"],"title":"路由转发和反向代理的应用","uri":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["default"],"content":"简单实践 1. 路由转发： 工业互联网环境下，很多上位机是双网卡或者多网卡，上位机通常处于多重网络环境下，就上位机本身而言，可以与这些网络进行通信，再缺少网络路由器的直接配置情况下，各个网络之间是不能直接进行通信的，极端网络环境下，直接使用PC网卡进行路由转发是可以快速解决跨网设备通信的，一般来说，路由转发是从IP层协议解决网络连通性问题，与一般的反向代理处于传输层的解决方案相比，能够更好的支持网络应用，但同时也增加了网络的路由跃点数，会对工业软件的认证授权产生影响。 下面主要从一个上位机多重网络联通性测试说明两个局域网环境下的路由转发应用： 假设局域网1中的PC1的IP地址为：172.11.100.25，对应的网卡编号为11，局域网2中的PC3的IP地址为:172.12.25.141，对应的网卡编号为15.上位机连接着局域网1和局域网2，对应的网络IP地址分别为172.11.100.249和172.12.25.130，对应的网卡编号分别为11和13。为了实现PC1和PC2互通（即相互可以ping通），需要做如下三步操作： 2. 配置PC1 PC1下cmd进入命令行，route print -4 查看当前路由，添加以下路由信息： route add 172.12.25.0 mask 255.255.255.0 172.11.100.249 metric 8 if 11 3. 配置PC2 PC2下注意，需要设置一个网卡的网关地址为空，然后进入到注册表下修改IPEnableRouter的值为1,IPEnableRouter的具体注册表路径为 “计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters” !注意：IPEnableRouter修改后需要重启电脑才能生效。 4. 配置PC3 PC3下cmd进入命令行，route print -4查看当前路由，添加以下路由信息： route add 172.11.100.0 mask 255.255.255.0 172.12.25.130 metric 8 if 15 至此，相关路由转发配置基本结束，PC1和PC3是可以相互ping通的。 想象一下，如果要打通多个上位机的局域网，需要怎样做？ ","date":"2019-10-15","objectID":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/:0:1","tags":["network"],"title":"路由转发和反向代理的应用","uri":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["default"],"content":"多个上位机网络通信 下面主要从两个上位机的多重网络连通性测试说明三个局域网环境下的路由转发应用： 在上面的网络情景下，增加局域网3，局域网3下的PC5的IP地址为：192.168.0.201，对应的网卡编号为11，上位机PC4连接着局域网2和局域网3，对应的IP地址分别为172.12.15.142和192.168.0.202，对应的网卡编号分别为11和13，为了打通PC5和PC1的网络，需要做如下五步操作： 1. 配置PC1 PC1下cmd进入命令行，route print -4查看当前路由，添加以下路由信息： route add 192.168.0.0 mask 255.255.255.0 172.11.100.249 metric 8 if 11 2. 配置PC2 PC2下cmd进入命令行，route print -4查看当前路由，添加以下路由信息： route add 192.168.0.0 mask 255.255.255.0 172.12.15.142 metric 8 if 11 3. 配置PC4 PC4下注意，需要设置一个网卡的网关地址为空，然后进入到注册表下修改IPEnableRouter的值1，,IPEnableRouter的具体注册表路径为 “计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters” ！注意：IPEnableRouter修改后需要重启电脑才能生效。 4. 配置PC5 PC5下cmd进入命令行，route print -4查看路由，添加以下路由信息： route add 172.11.100.0 mask 255.255.255.0 192.168.0.202 metric 8 if 11 5. 查看PC4路由并配置 PC4下cmd进入命令行，route print -4查看路由，添加以下路由信息： route add 172.11.100.0 mask 255.255.255.0 172.12.15.142 if 11 route add 192.168.0.0 mask 255.255.255.0 192.168.0.202 metric 8 if 13 至此，相关路由转发配置基本结束，PC1和PC5是可以相互ping通的。 会了三个局域网的路由转发，多个局域网的路由转发以此类推，就可以实现异构网络间的互通。 ","date":"2019-10-15","objectID":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/:0:2","tags":["network"],"title":"路由转发和反向代理的应用","uri":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":["default"],"content":"反向代理： 反向代理的应用非常广泛，包括网站负载均衡、内网穿透、高可用等等。由于反向代理一般都软件化了，这里就不做过多介绍，可以推荐使用frp作为反向代理，支持tcp、udp等多种协议。 当然windows自带的netsh interface portproxy也是一个不错的选择，但是只支持tcp协议。 参考文章： Win7中的路由转发配置实验 ","date":"2019-10-15","objectID":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/:0:3","tags":["network"],"title":"路由转发和反向代理的应用","uri":"/posts/2019/10/15/%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"},{"categories":null,"content":" 警告\r\rSorry, this article has not been completely translated into French. Welcome to take the time to propose a translation by :(fas fa-code-branch fa-fw): making a PR to the theme!\r\r :(far fa-kiss-wink-heart fa-fw): LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \"\rHugo Theme LoveIt\r ","date":"2019-08-02","objectID":"/about.fr/:0:0","tags":null,"title":"À propos de LoveIt","uri":"/about.fr/"},{"categories":null,"content":"Features Performance and SEO :(fas fa-rocket fa-fw): Optimized for performance: [99]/[100] on mobile and [100]/[100] on desktop in Google PageSpeed Insights :(fab fa-searchengin fa-fw): Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD :(fab fa-google fa-fw): Google Analytics supported :(far fa-chart-bar fa-fw): Fathom Analytics supported :(fas fa-search fa-fw): Search engine verification supported (Google, Bind, Yandex and Baidu) :(fas fa-tachometer-alt fa-fw): CDN for third-party libraries supported :(fas fa-cloud-download-alt fa-fw): Automatically converted images with Lazy Load by lazysizes Appearance and Layout [:(fas fa-desktop):]/[:(fas fa-mobile):] Responsive layout [:(fas fa-sun):]/[:(fas fa-moon):] [Light]/[Dark] mode :(fas fa-layer-group fa-fw): Globally consistent design language :(fas fa-ellipsis-h fa-fw): Pagination supported :(far fa-list-alt fa-fw): Easy-to-use and self-expanding table of contents :(fas fa-language fa-fw): Multilanguage supported and i18n ready :(fab fa-css3-alt fa-fw): Beautiful CSS animation Social and Comment Systems :(far fa-user fa-fw): Gravatar supported by Gravatar :(fas fa-user-circle fa-fw): Local Avatar supported :(far fa-id-card fa-fw): Up to 64 social links supported :(fas fa-share-square fa-fw): Up to 28 share sites supported :(far fa-comment fa-fw): Disqus comment system supported by Disqus :(far fa-comment-dots fa-fw): Gitalk comment system supported by Gitalk :(far fa-comment-alt fa-fw): Valine comment system supported by Valine :(far fa-comments fa-fw): Facebook comments system supported by Facebook :(fas fa-comment fa-fw): Telegram comments system supported by Comments :(fas fa-comment-dots fa-fw): Commento comments system supported by Commento Extended Features :(fas fa-search fa-fw): Search supported by Lunr.js or algolia :(far fa-grin-tongue-wink fa-fw): Twemoji supported :(fas fa-code fa-fw): Automatically highlighting code :(far fa-copy fa-fw): Copy code to clipboard with one click :(far fa-images fa-fw): Images gallery supported by lightgallery.js :(fab fa-font-awesome fa-fw): Extended Markdown syntax for Font Awesome icons :(far fa-sticky-note fa-fw): Extended Markdown syntax for ruby annotation :(fas fa-percentage fa-fw): Extended Markdown syntax for fraction :(fas fa-square-root-alt fa-fw): Mathematical formula supported by $ \\KaTeX $ :(fas fa-project-diagram fa-fw): Diagrams shortcode supported by mermaid :(fas fa-chart-pie fa-fw): Interactive data visualization shortcode supported by ECharts :(fas fa-map-marked-alt fa-fw): Mapbox shortcode supported by Mapbox GL JS :(fas fa-music fa-fw): Music player shortcode supported by APlayer and MetingJS :(fas fa-video fa-fw): Bilibili player shortcode :(far fa-bell fa-fw): Kinds of admonitions shortcode :(fas fa-align-left fa-fw): Custom style shortcode :(fas fa-i-cursor fa-fw): Animated typing supported by TypeIt :(fas fa-arrow-down fa-fw): Dynamic scroll supported by Smooth Scroll … ","date":"2019-08-02","objectID":"/about.fr/:0:1","tags":null,"title":"À propos de LoveIt","uri":"/about.fr/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine ","date":"2019-08-02","objectID":"/about.fr/:0:2","tags":null,"title":"À propos de LoveIt","uri":"/about.fr/"},{"categories":null,"content":" :(far fa-kiss-wink-heart fa-fw): LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \"\rHugo 主题 LoveIt\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO :(fas fa-rocket fa-fw): 性能优化：在 Google PageSpeed Insights 中， [99]/[100] 的移动设备得分和 [100]/[100] 的桌面设备得分 :(fab fa-searchengin fa-fw): 使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化 :(fab fa-google fa-fw): 支持 Google Analytics :(far fa-chart-bar fa-fw): 支持 Fathom Analytics :(fas fa-search fa-fw): 支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu) :(fas fa-tachometer-alt fa-fw): 支持所有第三方库的 CDN :(fas fa-cloud-download-alt fa-fw): 基于 lazysizes 自动转换图片为懒加载 外观和布局 [:(fas fa-desktop):]/[:(fas fa-mobile):] 响应式布局 [:(fas fa-sun):]/[:(fas fa-moon):] [浅色]/[深色] 主题模式 :(fas fa-layer-group fa-fw): 全局一致的设计语言 :(fas fa-ellipsis-h fa-fw): 支持分页 :(far fa-list-alt fa-fw): 易用和自动展开的文章目录 :(fas fa-language fa-fw): 支持多语言和国际化 :(fab fa-css3-alt fa-fw): 美观的 CSS 动画 社交和评论系统 :(far fa-user fa-fw): 支持 Gravatar 头像 :(fas fa-user-circle fa-fw): 支持本地头像 :(far fa-id-card fa-fw): 支持多达 64 种社交链接 :(fas fa-share-square fa-fw): 支持多达 28 种网站分享 :(far fa-comment fa-fw): 支持 Disqus 评论系统 :(far fa-comment-dots fa-fw): 支持 Gitalk 评论系统 :(far fa-comment-alt fa-fw): 支持 Valine 评论系统 :(far fa-comments fa-fw): 支持 Facebook 评论系统 :(fas fa-comment fa-fw): 支持 Telegram comments 评论系统 :(fas fa-comment-dots fa-fw): 支持 Commento 评论系统 扩展功能 :(fas fa-search fa-fw): 支持基于 Lunr.js 或 algolia 的搜索 :(far fa-grin-tongue-wink fa-fw): 支持 Twemoji :(fas fa-code fa-fw): 支持代码高亮 :(far fa-copy fa-fw): 一键复制代码到剪贴板 :(far fa-images fa-fw): 支持基于 lightgallery.js 的图片画廊 :(fab fa-font-awesome fa-fw): 支持 Font Awesome 图标的扩展 Markdown 语法 :(far fa-sticky-note fa-fw): 支持上标注释的扩展 Markdown 语法 :(fas fa-percentage fa-fw): 支持分数的扩展 Markdown 语法 :(fas fa-square-root-alt fa-fw): 支持基于 $ \\KaTeX $ 的数学公式 :(fas fa-project-diagram fa-fw): 支持基于 mermaid 的图表 shortcode :(fas fa-chart-pie fa-fw): 支持基于 ECharts 的交互式数据可视化 shortcode :(fas fa-map-marked-alt fa-fw): 支持基于 Mapbox GL JS 的 Mapbox shortcode :(fas fa-music fa-fw): 支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode :(fas fa-video fa-fw): 支持 Bilibili 视频 shortcode :(far fa-bell fa-fw): 支持多种注释的 shortcode :(fas fa-align-left fa-fw): 支持自定义样式的 shortcode :(fas fa-i-cursor fa-fw): 支持基于 TypeIt 的打字动画 shortcode :(fas fa-arrow-down fa-fw): 支持基于 Smooth Scroll 的滚动动画 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":["Web开发"],"content":"tornado异步网络编程实践 异步tornado请求 底层建立socket通讯，服务器采用epoll方案，即时返回请求，轮询到后台任务结束时，通过socket发送数据到客户端。 理解异步过程： http请求断了，tcp层面上的socket连接还在保持，客户端通过再次发送http请求，可以得到后台处理的结果，long pooling技术，socket套接字主要由ip地址、tcp/ip协议和端口号决定，利用epoll的套接字复用技术，能够保证任务请求能够发送到正确的客户端上， server { listen 80; server_name yourdomain.tld; location / { try_files $uri @tornado; } location @tornado { proxy_pass http://localhost:8888; } } user nginx; worker_processes 1; error_log /var/log/nginx/error.log; pid /var/run/nginx.pid; events { worker_connections 1024; use epoll; } http { # 在upstream中列出所有的tornado server,当然如果你要做不同的路由跳转的时候可以定义多个upstream upstream frontends { server 127.0.0.1:8000; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003; } include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; keepalive_timeout 65; proxy_read_timeout 200; sendfile on; tcp_nopush on; tcp_nodelay on; gzip on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/html text/css text/xml application/x-javascript application/xml application/atom+xml text/javascript; # Only retry if there was a communication error, not a timeout # on the Tornado server (to avoid propagating \"queries of death\" # to all frontends) proxy_next_upstream error; server { listen 80; # Allow file uploads client_max_body_size 50M; location ^~ /static/ { root /var/www; if ($query_string) { expires max; } } location = /favicon.ico { rewrite (.*) /static/favicon.ico; } location = /robots.txt { rewrite (.*) /static/robots.txt; } location / { proxy_pass_header Server; proxy_set_header Host $http_host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://frontends; } } } user nginx; worker_processes 1; error_log /var/log/nginx/error.log; pid /var/run/nginx.pid; events { worker_connections 1024; use epoll; } http { # 在upstream中列出所有的tornado server,当然如果你要做不同的路由跳转的时候可以定义多个upstream upstream frontends { server 127.0.0.1:8000; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003; } include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; keepalive_timeout 65; proxy_read_timeout 200; sendfile on; tcp_nopush on; tcp_nodelay on; gzip on; gzip_min_length 1000; gzip_proxied any; gzip_types text/plain text/html text/css text/xml application/x-javascript application/xml application/atom+xml text/javascript; # Only retry if there was a communication error, not a timeout # on the Tornado server (to avoid propagating \"queries of death\" # to all frontends) proxy_next_upstream error; server { listen 80; # Allow file uploads client_max_body_size 50M; location ^~ /static/ { root /var/www; if ($query_string) { expires max; } } location = /favicon.ico { rewrite (.*) /static/favicon.ico; } location = /robots.txt { rewrite (.*) /static/robots.txt; } location / { proxy_pass_header Server; proxy_set_header Host $http_host; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Scheme $scheme; proxy_pass http://frontends; } } } 参考 http://golubenco.org/understanding-the-code-inside-tornado-the-asynchronous-web-server-powering-friendfeed.html http://zqdevres.qiniucdn.com/data/20100927213110/index.html http://xiaorui.cc/2016/06/26/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8E%8B%E6%B5%8B%E5%BC%95%E8%B5%B7%E7%9A%84nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/ http://stackoverflow.com/questions/32261494/should-we-do-database-calls-async-with-tornado http://www.dongwm.com/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/ http://qinxuye.me/article/ways-to-continual-sync-browser-and-server/ ","date":"2016-09-08","objectID":"/posts/2016/09/08/tornado-async-web/:0:0","tags":["Web开发","tornado","python"],"title":"tornado异步网络编程实践","uri":"/posts/2016/09/08/tornado-async-web/"},{"categories":null,"content":"no module named libxmlmods","date":"2015-03-14","objectID":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/","tags":["python"],"title":"windows系统使用python环境","uri":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"windows系统使用python环境 ","date":"2015-03-14","objectID":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/:0:0","tags":["python"],"title":"windows系统使用python环境","uri":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"windows 64安装libxml2dom小记 用于解决no module named libxmlmods等错误 此网站上面有编译好了的各种python windows包. 我们首先下载libxml2-python 然后使用pip wheel安装： pip wheeel libxml2_python-2.9.2-cp27-none-win_amd64.whl pip install --use-wheel --no-index --find-links=wheelhouse libxml2-python easy_install libxml2dom 至此安装libxml2dom完毕 ","date":"2015-03-14","objectID":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/:0:1","tags":["python"],"title":"windows系统使用python环境","uri":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"windows 64安装pycurl小记 首先下载curl 64bit mingw 然后git clone https://github.com/pycurl/pycurl.git，进入到pycurl目录，修改setup.py CURL_DIR=$CURL_PATH 编译，安装，完毕。 以上方法还是没有安装成功，还是使用上面网站里的编译好的安装包进行安装，下载pycurl-7.19.5.1-cp27-none-win_amd64.whl 使用以下命令进行安装： pip wheel pycurl-7.19.5.1-cp27-none-win_amd64.whl pip install -- ","date":"2015-03-14","objectID":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/:0:2","tags":["python"],"title":"windows系统使用python环境","uri":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/"},{"categories":null,"content":"windows上的python环境搭建： 安装Anaconda。 ","date":"2015-03-14","objectID":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/:0:3","tags":["python"],"title":"windows系统使用python环境","uri":"/posts/2015/03/14/windows%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8python%E7%8E%AF%E5%A2%83/"},{"categories":["分布式"],"content":"RHadoop环境搭建 ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:0:0","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"Rhadoop环境搭建 在集成R和hadoop之前需要将hadoop以及R运行环境安装好,hadoop的安装可参见hadoop2.4.1安装笔记. ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:0","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"1.下载相关安装包: ```shell script $wget https://raw.githubusercontent.com/RevolutionAnalytics/rhdfs/master/build/rhdfs_1.0.8.tar.gz $wget https://raw.githubusercontent.com/RevolutionAnalytics/rmr2/3.1.0/build/rmr2_3.1.0.tar.gz $wget https://raw.githubusercontent.com/RevolutionAnalytics/rhbase/master/build/rhbase_1.2.0.tar.gz ``` ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:1","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"2. 安装R包: ```shell script $R \u003einstall.packages(c(\"rJava\", \"Rcpp\", \"RJSONIO\", \"bitops\", \"digest\", \"functional\", \"stringr\", \"plyr\", \"reshape2\", \"caTools\")) \u003einstall.packages(pkgs=\"rhdfs_1.0.8.tar.gz\") \u003einstall.packages(pkgs=\"rmr2_3.1.0.tar.gz\") ``` ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:2","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"3. 启动hadoop后测试安装是否成功 ```R \u003elibrary(rhdfs) \u003ehdfs.init() \u003ehdfs.ls(\"/\") \u003elibrary(rmr2) \u003efrom.dfs(to.dfs(1:100)) \u003efrom.dfs(mapreduce(to.dfs(1:100))) ``` ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:3","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"4. eclipse上搭建R开发环境 eclipse上通过StatET来开发R程序,可以通过安装StatET直接在eclipse上建立R项目并执行R语言程序. R与Java语言的交互是通过JRI来完成的,需要在eclipse中安装RJava Eclipse Plugin和加载jri包来完成.jri的包的位置在rjava包的安装目录下面 ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:4","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"5. eclipse上搭建hadoop开发环境 安装hadoop eclipse插件来开发hadoop环境下的mapreduce程序: 具体插件安装方式可以参见hadoop2x-eclipse-plugin ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:5","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["分布式"],"content":"6. eclipse上WTP插件的安装 WTP方便在eclipse上开发J2EE程序,可以通过添加源地址方便的安装: 源地址的一般格式为http://download.eclipse.org/webtools/repository/kepler Spark结合R语言开发… 参考 Install RHadoop with Hadoopn 2.2 RHadoop wiki eclipse安装StatET JRI的问题 R语言学习资料 combine Hadoop with R ","date":"2014-11-28","objectID":"/posts/2014/11/28/rhadoop-installation/:1:6","tags":["R","hadoop"],"title":"RHadoop环境搭建","uri":"/posts/2014/11/28/rhadoop-installation/"},{"categories":["排版"],"content":"latex数学符号 ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:0:0","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"latex数学符号 ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:0","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"数学模式重音符 \\(\\hat{a}\\) \\(\\check{a}\\) \\check{a} \\(\\tilde{a}\\) \\tilde{a} \\(\\acute{a}\\) \\acute{a} \\(\\grave{a}\\) \\grave{a} \\(\\dot{a}\\) \\dot{a} \\(\\ddot{a}\\) \\ddot{a} \\(\\breve{a}\\) \\breve{a} \\(\\bar{a}\\) \\bar{a} \\(\\vec{a}\\) \\vec{a} \\(\\widehat{A}\\) \\widehat{A} \\(\\widetilde{A}\\) \\widetilde{A} ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:1","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"小写希腊字母表 \\(\\alpha\\) \\alpha \\(\\theta\\) \\theta \\(o\\) o \\(\\upsilon\\) \\upsilon \\(\\beta\\) \\beta \\(\\vartheta\\) \\vartheta \\(\\pi\\) \\pi \\(\\phi\\) \\phi \\(\\gamma\\) \\gamma \\(\\iota\\) \\iota \\(\\varpi\\) \\varpi \\(\\varphi\\) \\varphi \\(\\delta\\) \\delta \\(\\kappa\\) \\kappa \\(\\rho\\) \\rho \\(\\chi\\) \\chi \\(\\epsilon\\) \\epsilon \\(\\lambda\\) \\lambda \\(\\varrho\\) \\varrho \\(\\psi\\) \\psi \\(\\varepsilon\\) \\varepsilon \\(\\mu\\) \\mu \\(\\sigma\\) \\sigma \\(\\omega\\) \\omega \\(\\zeta\\) \\zeta \\(\\nu\\) \\nu \\(\\varsigma\\) \\varsigma \\(\\eta\\) \\eta \\(\\xi\\) \\xi \\(\\tau\\) \\tau ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:2","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"大写希腊字母 \\(\\Gamma\\) \\Gamma \\(\\Lambda\\) \\Lambda \\(\\Sigma\\) \\Sigma \\(\\Psi\\) \\Psi \\(\\Delta\\) \\Delta \\(\\Xi\\) \\Xi \\(\\Upsilon\\) \\Upsilon \\(\\Omega\\) \\Omega \\(\\Theta\\) \\Theta \\(\\Pi\\) \\Pi \\(\\Phi\\) \\Phi ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:3","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"二元关系符 \\(\u003c\\) \u003c \\(\u003e\\) \u003e \\(=\\) = \\(\\leq or \\le\\) \\leq or \\le \\(\\geq or \\ge\\) \\geq or \\g \\(\\equiv\\) \\equiv \\(\\ll\\) \\ll \\(\\gg\\) \\gg \\(\\doteq\\) \\doteq \\(\\prec\\) \\prec \\(\\succ\\) \\succ \\(\\sim\\) \\sim \\(\\preceq\\) \\preceq \\(\\succeq\\) \\succeq \\(\\simeq\\) \\simeq \\(\\subset\\) \\subset \\(\\supset\\) \\supset \\(\\approx\\) \\approx \\(\\subseteq\\) \\subseteq \\(\\supseteq\\) \\supseteq \\(\\cong\\) \\cong \\(\\sqsubset\\) \\sqsubset \\(\\sqsupset\\) \\sqsupset \\(\\Join\\) \\Join \\(\\in\\) \\in \\(\\ni\\) \\ni,\\owns \\(\\propto\\) \\propto \\(\\vdash\\) \\vdash \\(\\dashv\\) \\dashv \\(\\models\\) \\models \\(\\mid\\) \\mid \\(\\parallel\\) \\parallel \\(\\perp\\) \\perp \\(\\smile\\) \\smile \\(\\frown\\) \\frown \\(\\asymp\\) \\asymp \\(:\\) : \\(\\notin\\) \\notin \\(\\neq\\) \\neq or \\ne ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:4","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"二元运算符号 \\(+\\) + \\(-\\) - \\(\\triangleleft\\) \\triangleleft \\(\\pm\\) \\pm \\(\\mp\\) \\mp \\(\\triangleright\\) \\triangleright \\(\\cdot\\) \\cdot \\(\\div\\) \\div \\(\\times\\) \\times \\(\\setminus\\) \\setminus \\(\\star\\) \\star \\(\\cup\\) \\cup \\(\\cap\\) \\cap \\(\\ast\\) \\ast \\(\\sqcup\\) \\sqcup \\(\\circ\\) \\circ \\(\\vee\\) \\vee,\\lor \\(\\wedge\\) \\wedge,\\land \\(\\bullet\\) \\bullet \\(\\oplus\\) \\oplus \\(\\ominus\\) \\ominus \\(\\diamond\\) \\diamond \\(\\odot\\) \\odot \\(\\oslash\\) \\oslash \\(\\uplus\\) \\uplus \\(\\otimes\\) \\otimes \\(\\bigcirc\\) \\bigcirc \\(\\amalg\\) \\(\\bigtriangleup\\) \\(\\bigtriangledown\\) \\(\\dagger\\) \\dagger \\(\\lhd\\) \\lhd \\(\\rhd\\) \\rhd \\(\\ddagger\\) \\ddagger \\(\\unlhd\\) \\unlhd \\(\\unrhd\\) \\unrhd \\(\\wr\\) \\wr ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:5","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"大尺寸运算符 \\(\\sum\\) \\sum \\(\\bigcup\\) \\bigcup \\(\\bigvee\\) \\bigvee \\(\\bigoplus\\) \\bigoplus \\(\\prod\\) \\prod \\(\\bigcap\\) \\bigcap \\(\\bigwedge\\) \\bigwedge \\(\\bigotimes\\) \\bigotimes \\(\\coprod\\) \\coprod \\(\\bigsqcup\\) \\bigsqcup \\(\\bigodot\\) \\bigodot \\(\\int\\) \\int \\(\\oint\\) \\oint \\(\\biguplus\\) \\biguplus ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:6","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["排版"],"content":"箭头 \\(\\leftarrow\\) \\leftarrow or \\gets \\(\\longleftarrow\\) \\longleftarrow \\(\\uparrow\\) \\uparrow \\(\\rightarrow\\) \\rightarrow or \\to \\(\\longrightarrow\\) \\longrightarrow \\(\\downarrow\\) \\downarrow \\(\\leftrightarrow\\) \\leftrightarrow \\(\\longleftrightarrow\\) \\longleftrightarrow 参考 mathsymb.pdf 常用数学符号的LaTex表示方法 ","date":"2014-09-10","objectID":"/posts/2014/09/10/latex-math-symbol/:1:7","tags":["排版","math"],"title":"latex数学符号","uri":"/posts/2014/09/10/latex-math-symbol/"},{"categories":["linux"],"content":"Function Programming","date":"2014-09-06","objectID":"/posts/2014/09/06/ubuntu-14.04-%E5%AE%89%E8%A3%85-haskell/","tags":["“haskell\""],"title":"ubuntu 14.04 安装 haskell","uri":"/posts/2014/09/06/ubuntu-14.04-%E5%AE%89%E8%A3%85-haskell/"},{"categories":["linux"],"content":"ubuntu 14.04 安装 haskell haskell是一种函数编程式语言，ghc是Glasgow Haskell Compiler的简称，也是Haskell Platform的基础. 下面是安装ghc的步骤： 下载源码并编译 sudo aptitude build-dep ghc sudo aptitude install git autoconf automake libtool make ncurses-dev g++ llvm gpaco wget https://www.haskell.org/ghc/dist/7.8.3/ghc-7.8.3-src.tar.bz2 tar jxvf ghc-7.8.3-src.tar.bz2 cd ghc-7.8.3-src ./configure --prefix=/usr/local/ghc make -j8 sudo paco -D make install sudo aptitude purge ghc 编辑.bashrc文件 PATH=\"/usr/local/ghc/bin:$PATH\" source ~/.bashrc ghci #验证是否安装成功 sudo aptitude purge ghc Cabal是Haskell的一个package，提供Haskell包安装框架，类似python的easy_install、debian的apt-get等。 cabal-install是另一个Haskell包安装库，提供了cabal命令行程序，该程序在安装新包时会自动解决包依赖关系。 安装了cabal-install就可以了，因为cabal-install依赖与cabal，安装程序会自动下载cabal并安装。 下面是安装cabal的步骤 下载源码并编译 wget http://www.haskell.org/cabal/release/cabal-install-1.20.0.3/cabal-install-1.20.0.3.tar.gz tar zxvf cabal-install-1.20.0.3.tar.gz cd cabal-install-2.10.0.3 ./bootstrap.sh vim ~/.bahsrc PATH=$HOME/.cabal/bin:$PATH source ~/.bashrc cabal update 异常处理 安装包haskell-platform中包含这些包，但是由于使用apt-get安装时不能获得最新的版本或者会出现一些问题，比如network-2.6.0.2通过cabal总是安装不上，报编译错误 这种使用源码安装的方式很好的解决了这些问题。非常高效！ 在安装相关haskell包的时候可能会出现broken package错误，可以通过以下命令在haskell中移除broken package ghc-pkg check --simple-output | xargs -n 1 ghc-pkg unregister --force 参考 how i start ","date":"2014-09-06","objectID":"/posts/2014/09/06/ubuntu-14.04-%E5%AE%89%E8%A3%85-haskell/:0:0","tags":["“haskell\""],"title":"ubuntu 14.04 安装 haskell","uri":"/posts/2014/09/06/ubuntu-14.04-%E5%AE%89%E8%A3%85-haskell/"},{"categories":null,"content":"散射卷积网络","date":"2014-08-09","objectID":"/posts/2014/08/09/scatter/","tags":["AI"],"title":"ScatNet散射卷积网络","uri":"/posts/2014/08/09/scatter/"},{"categories":null,"content":"ScatNet散射卷积网络 散射卷积网络(ScatNet)通过卷积网络对图像的小波系数做级联运算，运用深度学习的思想，生成树状结构的散射系数，使用散射系数作为特征进行学习。 理解和分析scatnet就暂且从下面这幅图入手 在这里，\\(f\\)为输入的图像矩阵数据、\\(\\phi\\)代表一个小波函数、m代表变换的阶数、J代表尺度,\\(\\lambda\\)代表路径对应于m定义的各个阶，左上箭头代表计算出的散射系数、U代表的是各个小波系数的模结果。散射算子对U变换将会计算出该层散射系数S和下一层的U。 若散射变换的方向数为C，总阶数为m，则第q阶散射变换沿频率递减的路径数为\\(C^{q}(^J_q)\\)，假设图像的橡树大小为N，采样值为\\(\\omega 2^{J}\\),则每条散射路径有\\(N\\omega^{-2}2^{-2J}\\)个系数，则所有的系数个数为 $$N\\omega^{-2}2^{-2J} \\sum_{q=0}^m C^{q}(^J_q)$$ 散射卷积网络、小波变换、分形、自然常数之间的关系 参考文章与资料： Invariant Scattering Convolution Networks High Dimensional Classification with Invariant Deep Networks ScatNet S.Mallat的一个访谈 Plenary Talk:Are Deep Networks a Solution to Curse of Dimensionality 2scatnet ","date":"2014-08-09","objectID":"/posts/2014/08/09/scatter/:0:0","tags":["AI"],"title":"ScatNet散射卷积网络","uri":"/posts/2014/08/09/scatter/"},{"categories":null,"content":"配置反向代理 ","date":"2014-06-05","objectID":"/posts/2014/06/05/reverse-proxy-setup/:0:0","tags":["network","linux"],"title":"配置反向代理","uri":"/posts/2014/06/05/reverse-proxy-setup/"},{"categories":null,"content":"建立一个简单的反向http代理 nginx 配置情况 upstream tunnel{ server 127.0.0.1:8080; } server { listen 80; server_name \u003curl\u003e; location /{ proxy_set_header Host $http_host; proxy_pass tunnel; } } #ssh reverse ssh -R 8080:localhost:\u003cport\u003e \u003cuser_name\u003e@\u003cserver\u003e #port is your local application used ,and url is the url you will to visit public ","date":"2014-06-05","objectID":"/posts/2014/06/05/reverse-proxy-setup/:1:0","tags":["network","linux"],"title":"配置反向代理","uri":"/posts/2014/06/05/reverse-proxy-setup/"},{"categories":null,"content":"Matalb与C/C__语言混合编程 用C++（或者C）语言操作MATLAB，有三种途径：MEX、MAT、引擎应用程序 1.MEX文件 在MATLAB中可调用的C或Fortran语言程序称为MEX文件。MATLAB可以直接把MEX文件视为它的内建函数进行调用。MEX文件是动态链接的子例程，MATLAB解释器可以自动载入并执行它。MEX文件主要有以下用途： 对于大量现有的C或者Fortran程序可以无须改写成MATLAB专用的M文件格式而在MATLAB中执行。 对于那些MATLAB运算速度过慢的算法，可以用C或者Frotran语言编写以提高效率。 2.MAT文件应用程序 MAT文件是MATLAB专用的用于保存数据至磁盘和向MATLAB导入、从MATLAB导出数据的数据文件格式。MAT文件提供了一种简便的机制，它允许你在两个平台之间以灵活的方式移动数据。而且，它还提供了一种途径来向其它单机MATLAB应用导入或者导出数据。 为了简化在MATLAB环境之外对MAT文件的使用，MATLAB给出了一个操作例程库，通过它，我们可以使用C/C++或者Fortran程序读写MAT文件。 3.引擎应用程序 MATLAB提供了一系列的例程使得别的程序可以调用MATLAB，从而把MATLAB用作一个计算引擎。MATLAB引擎程序指的是那些通过管道（在UNIX系统中）或者ActiveX（在Windows系统中）与独立MATLAB进程进行通信的C/C++或者Fortran程序。 MEX文件 #include “mex.h” /* *timestwo.c-example found in API guide * *Computational function that takes a scalar and doubles it * *This is a MEX-File for MATLAB. *Copyright(c) */ void timestwo(double y[],double x[]); void timestwo(double y[],double x[]) { y[0]=2.0*x[0]; } void mexFunction(int nlhs,mxArray* plhs[],int nrhs,const mxArray *prhs[]) /*nlhs是MATLAB命令行方式下输出参数的个数 *plhs是MATLAB命令行方式下的输出参数; *nrhs是MATLAB命令行方式下输入参数的个数； *prhs[]是MATLAB命令行方式下的输入参数； */ { double *x,*y; int mrows,ncols; /*Check for proper number of arguments.*/ if (nrhs!=1){ mexErrMsgTxt(“One input required”); } else if(nlhs\u003e=1) { mexErrMsgTxt(“Too many output arguments”); } /*在MATLAB命令行方式下，本MEX文件的调用格式是y=timestwo(x) 输入参数（x）个数=1，输出参数（y）个数=1，所以在程序一开始就检查 nrhs时候==1以及nlhs是否\u003e=1（因为MATLAB有一个缺省的输出参数ans，所以nlhs可以==0*/ /*The input must be a non comlex scalar double.*/ mrows=mxGetM(prhs[0]);//矩阵行数\u003cbr\u003e ncols=mxGetN(prhs[0]);//矩阵列数\u003cbr\u003e if (!mxIsDouble(prhs[0])|| mxIsComplex(prhs[0])||!(mrows==1\u0026amp;ncols==1)) { mexErrMsgTxt(“Input must be a noncomplex scalar double”); } //判断输入举证是否是double类，以及它是否只包含单个元素无嵌套 //为输出创建一个矩阵，显然这个矩阵也应该是1*1的 plhs[0]=mxCreateDoubleMatrix(mrows,ncols,mxREAL); x=mxGetPr(prhs[0]); y=mxGetPr(plhs[0]); timestwo(y,x); } matlab命令行上输入以下语句： mex testmex.cpp; x=2; y=testmex(x); MAT文件： libmat.dll:用于操作mat文件 libmx.dll:用于操作mat文件中的矩阵 MATLAB中常用的矩阵类型： (复)双精度矩阵： MATLAB中最常用的数据类型便是（复）双精度、非稀疏矩阵，这些矩阵的元素都是双精度（double）的，矩阵的尺寸为m×n，其中m是总行数，m是总列数。矩阵数据实际存放在两个双精度向量中——一个向量存放的是数据的实部，另一个向量存放的是数据的虚部。指向这两个向量的指针一般被写做“pr” （pointer to real data，指向实数据的指针）和“pi” （pointer to imaginary data，指向虚数据的指针）”。如果一个矩阵的pi为空的话，说明它是实双精度矩阵。 稀疏矩阵（Sparse Matrices） MATLAB中稀疏矩阵的存储格式与众不同。如同双精度矩阵一样，它拥有参数pr和pi，同时它还具用三个附加的参数：nzmax，ir以及jc。 nzmax是个整型数，其值为向量ir及pr、pi（如果存在的话）可能的最大长度。它是稀疏矩阵中不为零的元素的个数。 ir指向一个长度为nzmax的整型数阵列，阵列包含的是pr和pi中对应元素的行号。 jc指向一个长度为N+1的整型数阵列（N为矩阵的列数），其中包含的是列号信息。对于任意的j，如果0≤j≥N-1，jc[j]是第j列中第一个非零项在ir、pr（以及pi）中的序号，jc[j+1]-1是第j列最后一个非零项的序号。因此jc[N]总等于nnz——矩阵中非零项的总个数。如果nnz小于nzmax，可以继续向矩阵中添加非零项而无需分配额外的存储空间\u003c 主要函数举例: ·MATFile *matOpen(const char *filename, const char * mode)——打开/创建 ·MATFile *matOpen(const char *filename, const char * mode)——打开/创建一个MAT文件； ·int matClose(MATFile *pMF)——关闭一个MAT文件； ·mxArray *mxCreateDoubleMatrix(int m, int n, mxComplexity flag) #创建一个（复）双精度矩阵； ·mxArray *mxCreateSparse(int m, int n, int nzmax, mxComplexity flag) #创建一个稀疏矩阵； ·mxArray *matGetNextArray(MATFile *pMF)——获得MAT文件里面下一个矩阵； ·const char *mxGetName(const mxArray *pa)——获得矩阵pa的名称； ·void mxSetName(mxArray *pa,const char *s)——为矩阵pa设置一个名称； ·int mxGetM(const mxArray *pa)——获得矩阵pa的总行数； ·int mxGetN(const mxArray *pa)——获得矩阵pa的总列数； ·double *mxGetPr(const mxArray *pa)——获得矩阵pa的pr指针； ·int *mxGetIr(const mxArray *pa)——获得稀疏矩阵pa的ir指针； ·int *mxGetJc(const mxArray *pa)——获得稀疏矩阵pa的jc指针； ·int matPutArray(MATFile * pMF, const mxArray * pA) #把矩阵pA存储入MAT文件pMAF； ·void mxDestroyArray(mxArray *pa)——释放矩阵pa（把它从内存中撤销）； ","date":"2014-05-06","objectID":"/posts/2014/05/06/matlab-mixed-c/:0:0","tags":["matlab","hybird"],"title":"Matlab C混合编程","uri":"/posts/2014/05/06/matlab-mixed-c/"},{"categories":["人工智能"],"content":"计算机视觉论文源代码集锦 ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:0:0","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"计算机视觉、机器学习相关领域论文和源代码大集合–持续更新 ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:0","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"特征提取Feature Extraction SIFT [Demo program][SIFT Library] [VLFeat] PCA-SIFT [Project] Affine-SIFT [Project] SURF [OpenSURF] [Matlab Wrapper] Affine Covariant Features [Oxford project] MSER [Oxford project] [VLFeat] Geometric Blur [Code] Local Self-Similarity Descriptor [Oxford implementation] Global and Efficient Self-Similarity [Code] Histogram of Oriented Graidents [INRIA Object Localization Toolkit] [OLT toolkit for Windows] Shape Context [Project] Color Descriptor [Project] Pyramids of Histograms of Oriented Gradients [Code] Space-Time Interest Points (STIP) [Project] [Code] Boundary Preserving Dense Local Regions[Project] Weighted Histogram[Code] Histogram-based Interest Points Detectors[Paper][Code] An OpenCV – C++ implementation of Local Self Similarity Descriptors [Project] Fast Sparse Representation with Prototypes[Project] Corner Detection [Project] AGAST Corner Detector: faster than FAST and even FAST-ER[Project] 1 ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:1","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"图像分割Image Segmentation Normalized Cut [Matlab code] Gerg Mori’ Superpixel code [Matlab code] Efficient Graph-based Image Segmentation [C++ code] [Matlab wrapper] Mean-Shift Image Segmentation [EDISON C++ code] [Matlab wrapper] OWT-UCM Hierarchical Segmentation [Resources] Turbepixels [Matlab code 32bit] [Matlab code 64bit] [Updated code] Quick-Shift[VLFeat] SLIC Superpixels [Project] Segmentation by Minimum Code Length [Project] Biased Normalized Cut [Project] Segmentation Tree [Project] Entropy Rate Superpixel Segmentation [Code] Fast Approximate Energy Minimization via Graph Cuts[Paper][Code] Efﬁcient Planar Graph Cuts with Applications in Computer Vision[Paper][Code] Isoperimetric Graph Partitioning for Image Segmentation[Paper][Code] Random Walks for Image Segmentation[Paper][Code] Blossom V: A new implementation of a minimum cost perfect matching algorithm[Code] An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy Minimization in Computer Vision[Paper][Code] Geodesic Star Convexity for Interactive Image Segmentation[Project] Contour Detection and Image Segmentation Resources[Project][Code] Biased Normalized Cuts[Project] Max-flow/min-cut[Project] Chan-Vese Segmentation using Level Set[Project] A Toolbox of Level Set Methods[Project] Re-initialization Free Level Set Evolution via Reaction Diffusion[Project] Improved C-V active contour model[Paper][Code] A Variational Multiphase Level Set Approach to Simultaneous Segmentation and Bias Correction[Paper][Code] Level Set Method Research by Chunming Li[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:2","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"目标检测Object Detection A simple object detector with boosting [Project] INRIA Object Detection and Localization Toolkit [Project] Discriminatively Trained Deformable Part Models [Project] Cascade Object Detection with Deformable Part Models [Project] Poselet [Project] Implicit Shape Model [Project] Viola and Jones’s Face Detection [Project] Bayesian Modelling of Dyanmic Scenes for Object Detection[Paper][Code] Hand detection using multiple proposals[Project] Color Constancy, Intrinsic Images, and Shape Estimation[Paper][Code] Discriminatively trained deformable part models[Project] Gradient Response Maps for Real-Time Detection of Texture-Less Objects: LineMOD [Project] Image Processing On Line[Project] Robust Optical Flow Estimation[Project] Where’s Waldo: Matching People in Images of Crowds[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:3","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"显著性检测Saliency Detection Itti, Koch, and Niebur’ saliency detection [Matlab code] Frequency-tuned salient region detection [Project] Saliency detection using maximum symmetric surround [Project] Attention via Information Maximization [Matlab code] Context-aware saliency detection [Matlab code] Graph-based visual saliency [Matlab code] Saliency detection: A spectral residual approach. [Matlab code] Segmenting salient objects from images and videos. [Matlab code] Saliency Using Natural statistics. [Matlab code] Discriminant Saliency for Visual Recognition from Cluttered Scenes. [Code] Learning to Predict Where Humans Look [Project] Global Contrast based Salient Region Detection [Project] Bayesian Saliency via Low and Mid Level Cues[Project] Top-Down Visual Saliency via Joint CRF and Dictionary Learning [Paper] [Code] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:4","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"图像分类、聚类Image Classification, Clustering Pyramid Match [Project] Spatial Pyramid Matching [Code] Locality-constrained Linear Coding [Project] [Matlab code] Sparse Coding [Project] [Matlab code] Texture Classification [Project] Multiple Kernels for Image Classification [Project] Feature Combination [Project] SuperParsing [Code] Large Scale Correlation Clustering Optimization[Matlab code] Detecting and Sketching the Common[Project] Self-Tuning Spectral Clustering[Project][Code] User Assisted Separation of Reflections from a Single Image Using a Sparsity Prior[Paper][Code] Filters for Texture Classification[Project] Multiple Kernel Learning for Image Classification[Project] SLIC Superpixels[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:5","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"抠图Image Matting A Closed Form Solution to Natural Image Matting [Code] Spectral Matting [Project] Learning-based Matting [Code] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:6","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"目标跟踪Object Tracking A Forest of Sensors – Tracking Adaptive Background Mixture Models [Project] Object Tracking via Partial Least Squares Analysis[Paper][Code] Robust Object Tracking with Online Multiple Instance Learning[Paper][Code] Online Visual Tracking with Histograms and Articulating Blocks[Project] Incremental Learning for Robust Visual Tracking[Project] Real-time Compressive Tracking[Project] Robust Object Tracking via Sparsity-based Collaborative Model[Project] Visual Tracking via Adaptive Structural Local Sparse Appearance Model[Project] Online Discriminative Object Tracking with Local Sparse Representation[Paper][Code] Superpixel Tracking[Project] Learning Hierarchical Image Representation with Sparsity, Saliency and Locality[Paper][Code] Online Multiple Support Instance Tracking [Paper][Code] Visual Tracking with Online Multiple Instance Learning[Project] Object detection and recognition[Project] Compressive Sensing Resources[Project] Robust Real-Time Visual Tracking using Pixel-Wise Posteriors[Project] Tracking-Learning-Detection[Project][OpenTLD/C++ Code] the HandVu：vision-based hand gesture interface[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:7","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"Kinect Kinect toolbox[Project] OpenNI[Project] zouxy09 CSDN Blog[Resource] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:8","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"3D相关 3D Reconstruction of a Moving Object[Paper] [Code] Shape From Shading Using Linear Approximation[Code] Combining Shape from Shading and Stereo Depth Maps[Project][Code] Shape from Shading: A Survey[Paper][Code] A Spatio-Temporal Descriptor based on 3D Gradients (HOG3D)[Project][Code] Multi-camera Scene Reconstruction via Graph Cuts[Paper][Code] A Fast Marching Formulation of Perspective Shape from Shading under Frontal Illumination[Paper][Code] Reconstruction:3D Shape, Illumination, Shading, Reflectance, Texture[Project] Monocular Tracking of 3D Human Motion with a Coordinated Mixture of Factor Analyzers[Code] Learning 3-D Scene Structure from a Single Still Image[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:9","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"机器学习算法 Matlab class for computing Approximate Nearest Nieghbor (ANN) [Matlab class providing interface toANN library] Random Sampling[code] Probabilistic Latent Semantic Analysis (pLSA)[Code] FASTANN and FASTCLUSTER for approximate k-means (AKM)[Project] Fast Intersection / Additive Kernel SVMs[Project] SVM[Code] Ensemble learning[Project] Deep Learning[Net] Deep Learning Methods for Vision[Project] Neural Network for Recognition of Handwritten Digits[Project] Training a deep autoencoder or a classifier on MNIST digits[Project] THE MNIST DATABASE of handwritten digits[Project] Ersatz：deep neural networks in the cloud[Project] Deep Learning [Project] sparseLM : Sparse Levenberg-Marquardt nonlinear least squares in C/C++[Project] Weka 3: Data Mining Software in Java[Project] Invited talk “A Tutorial on Deep Learning” by Dr. Kai Yu (余凯)[Video] CNN – Convolutional neural network class[Matlab Tool] Yann LeCun’s Publications[Wedsite] LeNet-5, convolutional neural networks[Project] Training a deep autoencoder or a classifier on MNIST digits[Project] Deep Learning 大牛Geoffrey E. Hinton’s HomePage[Website] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:10","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"目标、行为识别Object, Action Recognition Action Recognition by Dense Trajectories[Project][Code] Action Recognition Using a Distributed Representation of Pose and Appearance[Project] Recognition Using Regions[Paper][Code] 2D Articulated Human Pose Estimation[Project] Fast Human Pose Estimation Using Appearance and Motion via Multi-Dimensional Boosting Regression[Paper][Code] Estimating Human Pose from Occluded Images[Paper][Code] Quasi-dense wide baseline matching[Project] ChaLearn Gesture Challenge: Principal motion: PCA-based reconstruction of motion histograms[Prpject] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:11","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"图像处理 Distance Transforms of Sampled Functions[Project] The Computer Vision Homepage[Project] ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:12","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["人工智能"],"content":"一些实用工具 EGT: a Toolbox for Multiple View Geometry and Visual Servoing[Project] [Code] a development kit of matlab mex functions for OpenCV library[Project] Fast Artificial Neural Network Library[Project] www.cvchina.info/2011/09/05/uiuc-cod/ ","date":"2014-05-06","objectID":"/posts/2014/05/06/ai-collection-2014/:1:13","tags":["计算机视觉","AI"],"title":"计算机视觉","uri":"/posts/2014/05/06/ai-collection-2014/"},{"categories":["Web开发"],"content":"tornado i18n国际化 i18n是国际化的简称（Internationalization,去掉开始的I和最后的N，中间一共18个字符）。 tornado中使用i18n,需要下面两个工具(pygettext,msgfmt)和两个相关文件（po文件和mo文件） ","date":"2014-04-27","objectID":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/:0:0","tags":["python","web"],"title":"tornado 国际化实践","uri":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/"},{"categories":["Web开发"],"content":"pygetext和msgfmt的使用方法 编写python代码文件 test.py from gettext import gettext as _ print _(\"well down\") print _(\"good\") 运行以下命令 pygetext test.py 生成messages.pot文件,更改文件后缀 mv messages.pot messages.po 配置msgstr值 生成一个名为messages.mo文件： msgfmt messages.po #建立目录locale/cn/LC_MESSAGES/ mv messages.po locale/cn/LC_MESSAGES cn目录是所对应的语言，LC_MESSAGES是gettext.py文件里要求的 mo文件必须和所定义的域同名 gettext.py中有 modfile=os.path.join(localedir,lang,‘LC_MESSAGES’,'%s.mo' %domain) 测试： $python \u003e\u003e\u003egettext.install('messages','./locale',unicode=True) 三个参数： 作用域名:用于限定翻译文件的主名 路径:存放翻译文件的路径 unicode:是否使用unicode（如果应用程序是unicode的，此处应设为True) \u003e\u003e\u003egettext.translation('messages','./locale',languages=['cn']).install(True) \u003e\u003e\u003eprint _(\"good\") ","date":"2014-04-27","objectID":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/:0:1","tags":["python","web"],"title":"tornado 国际化实践","uri":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/"},{"categories":["Web开发"],"content":"tornado中的应用 运行以下命令 $xgettext -L python -k=_ -o openquant.po $(find . -name \\*.py) $(find template/ -name \\*.html) 查找所有需要翻译的相关项生成 po 文件 $msgfmt openquant.po -o locale/zh_CN/LC_MESSAGES/openquant.mo 完成mo文件的生成 完成相关文件的生成后，需要在代码中加载: tornado.locale.load_gettext_translations(options.I18N_PATH,\"openquant\") handler中自定义get_user_locale函数： def get_user_locale(self): #zh_CN or en_US user_locale = self.get_cookie(\"user_locale\") if user_locale: return tornado.locale.get(user_locale) return None 参考 iMind django多国语言 ","date":"2014-04-27","objectID":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/:0:2","tags":["python","web"],"title":"tornado 国际化实践","uri":"/posts/2014/04/27/tornado-%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5/"},{"categories":null,"content":"ubuntu上构建ios交叉编译环境 ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:0","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"ubuntu 12.04 安装llvm3.4、ios-lang交叉编译环境 在ubuntu 12.04上先安装gcc-4.8，然后安装llvm,clang,libcxx,libcxxabi.由于libcxx和libcxxabi相互依赖，需要两次安装libcxx。最后安装theos等开放的ios开发工具链 安装gcc-4.8如前文所述install gcc4.8 on ubuntu 12.04 ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:1","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"安装llvm,clang /etc/apt/sources.list中添加如下两行： deb http://llvm.org/apt/precise/ llvm-toolchain-precise-3.4 main deb-src http://llvm.org/apt/precise/ llvm-toolchain-precise-3.4 main ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:2","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"检索签名： wget -O - http://llvm.org/apt/llvm-snapshot.gpg.key|sudo apt-key add - ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:3","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"安装与llvm-3.4,clang-3.4相关的所有包： apt-get install clang-3.4 clang-3.4-doc libclang-common-3.4-dev libclang-3.4-dev libclang1-3.4 libclang1-3.4-dbg libllvm-3.4-ocaml-dev libllvm3.4 libllvm3.4-dbg lldb-3.4 llvm-3.4 llvm-3.4-dev llvm-3.4-doc llvm-3.4-examples llvm-3.4-runtime clang-modernize-3.4 clang-format-3.4 python-clang-3.4 lldb-3.4-dev ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:4","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"安装libcxx： svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:5","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"查看g++使用的头文件: echo | g++ -Wp,-v -x c++ - -fsyntax-only ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:6","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"将会输出类似如下结果： ignoring nonexistent directory \"/usr/local/include/x86_64-linux-gnu\" ignoring nonexistent directory \"/usr/lib/gcc/x86_64-linux- gnu/4.8/../../../../x86_64-linux-gnu/include\" ### #include \"...\" search starts here: ### include \u003c...\u003e search starts here: /usr/include/c++/4.8 /usr/include/c++/4.8/x86_64-linux-gnu /usr/include/c++/4.8/backward /usr/lib/gcc/x86_64-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed /usr/include/x86_64-linux-gnu /usr/include End of search list. ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:7","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"编译安装libcxx： CC=clang CXX=clang++ cmake -G \"Unix Makefiles\" -DLIBCXX_CXX_ABI=libsupc++ - DLIBCXX_LIBSUPCXX_INCLUDE_PATHS=\"/usr/include/c++/4.7/;/usr/include/x86_64-linux- gnu/c++/4.7/\" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr \u003clibc++-source-dir\u003e make sudo make install ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:8","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"安装libcxxabi 首先安装相关依赖： sudo apt-get install g++ subversion cmake swig python-dev libedit-dev libunwind8 libunwind8-dev ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:9","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"下载源码并编译： svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi cd libcxxabi/lib ./buildit sudo cp libc++abi.so.1.0 /usr/lib sudo ln -s /usr/lib/libc++abi.so.1.0 /usr/lib/libc++abi.so.1 sudo ln -s /usr/lib/libc++abi.so.1 /usr/lib/libc++abi.so ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:10","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"使用libc++abi来安装libc++ svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx cd libcxx mkdir build cd build CC=clang CXX=clang++ cmake -G \"Unix Makefiles\" -DLIBCXX_CXX_ABI=libcxxabi - DLIBCXX_LIBCXXABI_INCLUDE_PATHS=\"\u003clibc++abi-source-dir\u003e/include\" - DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr ../ make sudo make install 至此ubuntu 12.04上的LLVM环境就算搭建好了。 ","date":"2014-04-12","objectID":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/:0:11","tags":["linux","compiler","toolchain"],"title":"ubuntu上构建ios交叉编译环境","uri":"/posts/2014/04/12/ubuntu-install-ios-llvm-chain/"},{"categories":null,"content":"MySQL使用总结 ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql创建数据库 create database sina default character set utf8mb4 collate utf8mb4_unicode_ci; ALTER DATABASE db_name DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 使用utf8mb4而不是utf8 ，应为utf8的长度不确定，utf8编码占用3个字节，utf8mb4能保证长度的够用， 5.5.3 版本以后的mysql版本开始支持utf8mb4 ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:1","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql导入导出 导出所有库 mysqldump -uusername -ppassword --all-databases\u003eall.sql 导入所有库 mysql\u003esource all.sql; 导出某些库 mysqldump -uusername -ppassword --databases db1 db2 \u003edb1db2.sql 导入某些库 mysql\u003esource db1db2.sql 导入某个库 mysql -uusername -ppassword db1\u003cdb1.sql; mysql\u003esource db1.sql; 导出某个库 mysqldump -uusername -ppassword db1 table1 table2\u003etb1tb2.sql 导入某些数据表 mysql -uusername -ppassword db1\u003ctb1tb2.sql mysql\u003euser db1; mysql\u003esource tb1tb2.sql; mysqldump字符集设置 $mysqldump -uusername -ppassword --default-character-set=utf-8 db1 table1\u003etb1.sql ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:2","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql用户管理 创建用户 mysql\u003e insert into mysql.user(Host,User,Password) values(\"localhost\",\"phplamp\",password(\"1234\")); mysql\u003egrant all privileges on *.* to jee@localhost identified by ‘123′； 修改用户密码 mysql\u003e UPDATE mysql.user SET password=PASSWORD(’新密码’) WHERE User=’root’; mysql\u003e FLUSH PRIVILEGES; 显示当前用户 mysql\u003eselect USER(); 第一次启用用户 进入到/etc/mysql/debian.cnf查看用户名和密码（）后临时登录到mysql shell，运行一下命令，设置root用的密码为123456。 use mysql; // 下面这句命令有点长，请注意。 update mysql.user set authentication_string=password('root') where user='root' and Host ='localhost'; update user set plugin=\"mysql_native_password\"; flush privileges; quit; ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:3","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"mysql大小写敏感配置 查看 show global variables like '%lower_case%' 配置 #0-大小写敏感，1-不敏感（先把表名转为小写，再执行操作）。 lower_case_table_names = 0 或lower_case_table_names =1 #my.cnf文件下 ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:4","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql启用远程 cd /etc/mysql vi my.cnf #注释bind-address mysql -uusername -ppassword #进入到mysql grant all privileges on *.* to username@'deniedhost' identified by 'password'; GRANT ALL PRIVILEGES ON *.* TO user_name@'%' IDENTIFIED BY ‘pass_word’; #if dynamic ip flush privileges; quit; ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:5","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql 主从复制 mysql复制的用途: 读取扩展 主备份服务器 故障转移服务器 地理空间冗余 数据仓库 基准测试 软件更新 复制配置(my.cnf): 主服务器配置(Alpha) [mysqld] log-bin=binary-log #log-bin参数启动二进制日志.二进制日志在MySQL环境中提供了多种用途.它为MySQL复制提供了DDL和DML语句流,能够重新应用于复制的从服务器. server-id=1 重新启动MySQL后 ,使用SQL命令show master status;进行验证.(对于配置复制的从服务器是必要的) 从服务器配置(Beta) [mysqld] server-id=2 read_only=TRUE show slave status; change master to MASTER_HOST='192.168.100.1',#主服务器上的用户名和密码 MASTER_USER='rep1', MASTER_PASSWORD='rep12009'; change master to MASTER_LOG_FILE='binary-log.00001',#主服务器上运行show master status命令所检索到的日志文件名称和位置. MASTER_LOG_POS=106; slave start;#启动从服务器验证其操作 show slave status;#Slave_IO_Running和Slave_SQL_Running的值为Yes,就证明\"主服务器-从服务器\"式的MySQL拓扑已经正常运行. ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:6","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"测试MySQL复制 在alpha上测试下面的代码: PROMPT alpha\u003e; alpha\u003e 确认从服务器上什么都不存在: beta\u003e show schemas; ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:7","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"Mysql 创建视图 create view v as select * from table; create view v as select id,name,age from table; create view v[vid,vname,vage] as select id,name,age from table; ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:8","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"ubuntu mysql5.7解决不用密码也能登陆: 登录mysql mysql -u root -p 或 mysql use mysql; update user set authentication_string=PASSWORD(\"密码\") where user='root'; update user set plugin=\"mysql_native_password\"; flush privileges; quit; /etc/init.d/mysql restart; mysql -u root -p 密码; ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:9","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"on,where,having的区别 on,where,having这三个都可以加条件的子句中,on是最先执行,where次之,having最后.有时候如果这先后顺序不影响中间结果的话,那最终结果是相同的.但因为on是先把不符合条件的记录过滤后才进行统计,它就可以减少中间运算要处理的数据,按理说应该速度是最快的. 根据上面的分析,可以知道where应该比having快一点,应为它过滤数据后才进行sum,所以having是最慢的.但也不是说having没用,因为有时在步骤三还没有出来都不知道那个记录才符合要求时,就要用having了. left join加上where 条件 用where是先连接然后再筛选 用and是先筛选再连接 数据库范式: 第一范式:强调的是列的原子性. 第二范式:首先使1NF,另外包含两部分内容,一是表必须有一个主键;二是没有包含在主键中的列必须完全依赖于主键,而不能只依赖于主键的一部分. 第三范式:首先是2NF,另外非主键列必须直接依赖于主键,不能存在传递依赖.即不能存在:非主键列A依赖于非主键列B,非主键列B依赖于主键的情况. ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:10","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"查询优化 jvm调优，内存结构 内存碎片问题 MajorGC是清理老年代 MinorGC是从年轻代空间（包括Eden和Survivor区域）回收内存。 FullGC是清理整个堆空间包括年轻代和老年代。 mysql执行计划，查询慢 MySQL查询优化： 查询性能衡量标准 查询时间 慢查询（几乎所有大道秒级别的查询都可以认为比较慢） 执行计划 type查询的方式 key使用的索引 Rows结果集大小 Extra提示信息 影响查询性能的因素 SQL解析时间#使用prepared stmt语句减少重复SQL的解析 查询优化算法 执行计划分析 索引优化 表优化（建主键unsigned int） 表优化（字段尽量使用NOT NULL） 表优化（能使用enum的尽量不要使用varchar） 表优化（ip字段使用unsigned int并使用INET_NTOA和INET_ATON) 索引优化（为频繁搜索的字段建立索引） 索引优化（为varchar text建立全文索引，避免使用 like) 索引优化（避免使用blob字段，该字段只能建立前缀索引） 索引优化（最多匹配原则和最高区分度原则） 查询优化 索引字段不参与计算，否则索引失效 避免使用 select*，select count(*)等 知道结果数量的使用，使用limit，尽早结果过程。 Query Cache的使用#关了吧 磁盘IO次数#IO优化，增大buffer pool，开取MRR，避免select * 事务键锁的影响#锁优化：避免使用大事务，RC比RR好，不适用GAP锁，避免使用select *，可能会锁权标 join优化#利用index nexted-loop join算法，在没有索引的情况下，合理设置join_buffer_size. 走索引OR全表扫描 结果集大小与运算过程 查询计划分析 查询优化技巧 MySQL执行计划 语法： EXPLAIN select ... 变体： 1.将执行计划“反翻译”成SELECT 语句，运行show warnings 可得到MySQL优化器优化后的查询语句 EXPLAIN EXTENDED select ... 2.用于分区表的EXPLAIN EXPLAIN PARTITIONS SELECT ... 执行计划包含的信息 id:包含一组数字，标识查询语句中执行SELECT子句或者操作表的顺序。id相同，执行顺序由上至下。若是子查询，id序号递增，id值越大优先级越高，越会被执行 select_type:表示每个select子句的类型（简单或复杂） SIMPLE：查询中不包含子查询或者UNION PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为该类型 SUBQUERY:在SELECT或where列表中包含了子查询，该子查询就被标记为SUBQUERY DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生） UNION：若第二个SELECT出现在UNION之后，则被标记为UNION UNION RESULT：从UNION表获取结果的SELECT被标记为UNION RESULT type：标识MySQL在表中找到所需行的方式，又称为“访问类型” 这列很重要,显示了连接使用了哪种类别,有无使用索引. 从最好到最差的连接类型为const、eq_reg、ref、range、index和AL mysql explain用法和结果的含义：https://www.cnblogs.com/yycc/p/7338894.html MYSQL 5.6.3以前只能EXPLAIN SELECT; MYSQL5.6.3以后就可以EXPLAIN SELECT,UPDATE,DELETE 不走索引情况 select * tb1 where name like ‘%comnn’ %再在前不走索引 select * tb1 where reverse（name） = ‘xu’ 条件出现函数运算不走索引 使用 or 不走索引 特别的： 当or条件中有 未 建立索引的列，会走索引 数据类型不一致 select * tb1 where name = 0999 ！= 特别的： 如果是主键 索引生效 \u003e 特别的： 如果是主键 或者索引是int类型 索引生效 order by 选择的映射是索引才生效 特别的： 如果是主键 索引生效 参考 无法启动mongodb的解决方法 启用远程mysql ","date":"2014-04-04","objectID":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["数据库"],"title":"MySQL使用总结","uri":"/posts/2014/04/04/mysql%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"命令行中输入以下命令安装相关包 sudo apt-get install python-software-properties sudo add-apt-repository ppa:boost-latest/ppa sudo apt-get update sudo apt-get install libboost1.55-all-dev sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-4.8 g++-4.8 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 60 --slave /usr/bin/g++ g++ /usr/bin/g++-4.6 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8 sudo update-alternatives --config gcc 安装完gcc-4.8后即可安装llvm-3.4 参考 llvm/apt 下载osxcross 编译若出现错误： fatal error:limits can’t find? 使用以下命令进行修正 $echo '#include \u003climits.h\u003e' | clang -v -xc -o /dev/null - 使用上述命令排错，依依对照toolchain查找的include顺序，修改include链接，即可解决问题 其实这是一个llvm的bug 临时解决方案 $cd /usr/lib/clang/\u003cclang-version/ $sudo ln -sf ../../llvm-3.4/lib/clang/\u003cclang-version\u003e/include include 再次编译可以通过。 一个查找文件的有用命令: $grep notification `find ./*` 参考： https://bugs.launchpad.net/ubuntu/+source/llvm-defaults/+bug/1242300: ","date":"2014-04-02","objectID":"/posts/2014/04/02/ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85gcc/:0:0","tags":["linux","toolchain"],"title":"ubuntu上安装gcc","uri":"/posts/2014/04/02/ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85gcc/"},{"categories":null,"content":"Ubuntu Server安装World Community Grid ","date":"2013-11-19","objectID":"/posts/2013/11/19/ubuntu-install-wcg/:0:0","tags":["linux"],"title":"Ubuntu Server安装World Community Grid","uri":"/posts/2013/11/19/ubuntu-install-wcg/"},{"categories":null,"content":"在ubuntu上安装BOINC sudo apt-get aptitude install boinc-client (you can also download it from wcg and install) find your account key: boinccmd --lookup_account http://www.worldcommunitygrid.org username password You should get a response something like this dfb74c9b9… attach to your project boinccmd --project_attach http://www.worldcommunitygrid.org dfb74c.... if you want to verify your attached enter the following command: boinccmd --get_state ","date":"2013-11-19","objectID":"/posts/2013/11/19/ubuntu-install-wcg/:1:0","tags":["linux"],"title":"Ubuntu Server安装World Community Grid","uri":"/posts/2013/11/19/ubuntu-install-wcg/"},{"categories":null,"content":"更多资源: http://boinc.berkeley.edu/wiki/installing_BOINC_ON_Ubuntu http://boinc.berkeley.edu/wiki/Client_configuration http://boinc.berkeley.edu/wiki/Stop_or_start_BOINC ","date":"2013-11-19","objectID":"/posts/2013/11/19/ubuntu-install-wcg/:1:1","tags":["linux"],"title":"Ubuntu Server安装World Community Grid","uri":"/posts/2013/11/19/ubuntu-install-wcg/"},{"categories":null,"content":"参考: http://blog.joelchristian.com/?p=291 http://misctechmusings.com/linux/boinc-cli-for-world-community-grid/ ","date":"2013-11-19","objectID":"/posts/2013/11/19/ubuntu-install-wcg/:1:2","tags":["linux"],"title":"Ubuntu Server安装World Community Grid","uri":"/posts/2013/11/19/ubuntu-install-wcg/"},{"categories":["Web开发"],"content":"网站部署记录 安装基础python环境 sudo apt-get install nginx sudo apt-get install git sudo apt-get install mysql-server sudo apt-get install python-dev install easy_install on ubuntu: sudo apt-get install python-setuptools sudo easy_install virtualenv sudo easy_install pip virtualenv ~/trade source ~/trade/bin/activate install numpy scipy pandas and ta-lib sudo pip install Cython 安装 blas libs sudo apt-get install gfortran libopenblas-dev liblapack-dev g++ pip install numpy pip install scipy 安装 ta-lib cd ~ wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz sudo apt-get install build-essential tar -zxvf ta-lib-0.4.0-src.tar.gz cd ta-lib-0.4.0 ./configure --prefix=/usr make sudo make install 安装 gevent wget https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz tar -zxvf ./configure make sudo make install cd ~/www git clone https://github.com/pydata/pandas.git git clone https://github.com/mrjbq7/ta-lib.git update the nginx sudo apt-get install python-software-properties sudo apt-get install sotware-properties-common sudo add-apt-repository ppa:nginx/stable sudo apt-get update sudo apt-get install nginx mysql init sudo apt-get install mysql-server libmysqld-dev pip install MySQL-python insert into mysql.user(Host,User,Password) values(\"localhost\",\"username\",password(\"password\")); 用户授权 给本地用户mql分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123456。 mysql\u003egrant all privileges on *.* to username@localhost identified by 'password'; 安装 redis 具体参考install redis 安装uwsgi 或者 gunicorn(可选) ","date":"2013-10-27","objectID":"/posts/2013/10/27/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/:0:0","tags":["linux"],"title":"网站部署记录","uri":"/posts/2013/10/27/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"ubuntu系统安装numpy和scipy ","date":"2013-10-18","objectID":"/posts/2013/10/18/ubuntu-install-numpy-scipy/:0:0","tags":["linux","python"],"title":"ubuntu系统安装numpy和scipy","uri":"/posts/2013/10/18/ubuntu-install-numpy-scipy/"},{"categories":null,"content":"linux上安装numpy scipy sudo pip install numpy sudo apt-get install libatlas-base-dev gfortran sudo pip install scipy sudo pip install matplotlib # recommended ","date":"2013-10-18","objectID":"/posts/2013/10/18/ubuntu-install-numpy-scipy/:1:0","tags":["linux","python"],"title":"ubuntu系统安装numpy和scipy","uri":"/posts/2013/10/18/ubuntu-install-numpy-scipy/"},{"categories":null,"content":"django中使用sqlalchemy进行动态映射 sqlalchemy动态映射 代码如下: from sqlalchemy import * from sqlalchemy.orm import * metadata=MetaData(create_engine(\"sqlite://\",echo=True) t1=Table(\"t1\",metadata,Column('id',Integer,primary_key=True)) t2=Table(\"t2\",metadata,Column(\"id\",Integer,primary_key=True)) metadata.create_all() def map_class_to_some_table(cls,table,entity_name,**kw): newcls=type(entity_name,(cls,),{}) mapper(newcls,table,**kw) return newcls class Foo(object): pass T1Foo=map_class_to_some_table(Foo,t1,\"T1Foo\") T2Foo=map_class_to_some_table(Foo,t2,\"T2Foo\") sess=sessionmaker()() sess.add_all([T1Foo(),T1Foo(),T2Foo(),T1Foo()]) print sess.query(T1Foo).all() print sess.query(T2Foo).all() ","date":"2013-07-26","objectID":"/posts/2013/07/26/django-sqlalchemy-mapping/:0:0","tags":["python","django","数据库"],"title":"sqlalchemy动态映射","uri":"/posts/2013/07/26/django-sqlalchemy-mapping/"},{"categories":null,"content":"python异步网络编程初探 ","date":"2013-07-15","objectID":"/posts/2013/07/15/python-async-programming/:0:0","tags":["分布式","python"],"title":"使用python进行异步网络编程","uri":"/posts/2013/07/15/python-async-programming/"},{"categories":null,"content":"使用python进行select,poll,epoll 测试 ","date":"2013-07-15","objectID":"/posts/2013/07/15/python-async-programming/:1:0","tags":["分布式","python"],"title":"使用python进行异步网络编程","uri":"/posts/2013/07/15/python-async-programming/"},{"categories":null,"content":"select测试 # selecttest.py import select import socket import Queue #create a socket server=socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.setblocking(False) #set option reused server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) server_address=('localhost',10001) server.bind(server_address) server.listen(10) #sockets from which we except to read inputs=[server] #sockets from which we expect to write outputs=[] #Outgoing message queues (socket:Queue) message_queues={} #A optional parameter for select is TIMEOUT timeout=20 while inputs: print \"waiting for next event\" #first parameter--read list,second parameter--write list,third parameter--error list readable,writable,exceptional=select.select(inputs,outputs,inputs,timeout) #when timeout reached,select return three empty list if not (readable or writable or exceptional): print \"Time out!\" break; for s in readable: if s is server: #A \"readable\" socket is ready to accept a connection connection,client_address=s.accept() print \" connection from\",client_address connection.setblocking(0) inputs.append(connection) message_queues[connection]=Queue.Queue() else: data=s.recv(1024) if data: print \"received \",data, \"from \",s.getpeername() message_queues[s].put(data) #Add output channel for response if s not in outputs: outputs.append(s) else: #Interpret empty result as closed connection print \" closing\", client_address if s in outputs: outputs.remove(s) inputs.remove(s) s.close() #remove message queue del message_queues[s] for s in writable: try: next_msg=message_queues[s].get_nowait() except Queue.Empty: print \" \",s.getpeername,\" queue empty\" outputs.remove(s) else: print \"sending \",next_msg,\" to\",s.getpeername() s.send(next_msg) for s in exceptional: print \" exception condition on \",s.getpeername() #stop listening for input on the connection inputs.remove(s) if s in outputs: outputs.remove(s) s.close() #Remove message queue ","date":"2013-07-15","objectID":"/posts/2013/07/15/python-async-programming/:1:1","tags":["分布式","python"],"title":"使用python进行异步网络编程","uri":"/posts/2013/07/15/python-async-programming/"},{"categories":null,"content":"poll测试 import socket import select import Queue server=socket.socket(socket.AF_INET,socket.SOCK_STREAM) server.setblocking(False) server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) server_address=(\"localhost\",10001) print \"Starting up on %s port %s\" % server_address server.bind(server_address) server.listen(5) message_queues={} #The timeout value is represente in milliseconds,instead of seconds timeout=100 #Create a limit for the next READ_ONLY=(select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR) READ_WRITE=(READ_ONLY|select.POLLOUT) #set up the poller poller=select.poll() poller.register(server,READ_ONLY) #map file descriptors to socket objects fd_to_socket={server.fileno():server,} while True: print \"Waiting for the next event\" events=poller.poll(timeout) print \"*\"*20 print len(events) print events print \"*\"*20 for fd,flag in events: s=fd_to_socket[fd] if flag \u0026 (select.POLLIN|select.POLLPRI): if s is server: #A readable socket is ready to accept a connection connection,client_address=s.accept() print \"Connection \",client_address connection.setblocking(False) fd_to_socket[connection.fileno()]=connection poller.register(connection,READ_ONLY) #Give the connection a queue to send data message_queues[connection]=Queue.Queue else: data=s.recv(1024) if data: # A readable client socket has data print \" received %s from %s \" % (data,s.getpeername()) message_queues[s].put(data) poller.modify(s,READ_WRITE) else: #Close the connection print \" closing \",s.getpeername() #Stop listening for input on the connection poller.unregister(s) s.close() del message_queues[s] elif flag \u0026 select.POLLHUP: #A client that \"Hang up\",to be closed. print \"closing \",s.getpeername,\"(HUP)\" poller.unregister(s) s.close() elif flag \u0026 select.POLLOUT: #SOCKET is ready to send DATA,if there is any to send try: next_msg=message_queues[s].get_nowait() except Queue.Empty: #No messages waiting so stop checking print s.getpeername,\" queue empty\" poller.modify(s,READ_ONLY) else: print \" sending %s to %s\" %(next_msg,s.getpeername()) s.send(next_msg) elif flag \u0026 select.POLLERR: #Any events with POLLER cause the server to close the sockets print \" exception on\",s.getpeername() poller.unregister(s) s.close() del message_queues[s] ","date":"2013-07-15","objectID":"/posts/2013/07/15/python-async-programming/:1:2","tags":["分布式","python"],"title":"使用python进行异步网络编程","uri":"/posts/2013/07/15/python-async-programming/"},{"categories":null,"content":"epoll测试 import socket,logging import select,errno logger=logging.getLogger(\"network-server\") def InitLog(): logger.setLevel(logging.DEBUG) fh=logging.FileHandler(\"network-server.log\") fh.setLevel(logging.DEBUG) ch=logging.StreamHandler() ch.setLevel(logging.DEBUG) formatter=logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s -%(message)s\") ch.setFormatter(formatter) fh.setFormatter(formatter) logger.addHandler(fh) logger.addHandler(ch) if __name__==\"__main__\": InitLog() try: listen_fd=socket.socket(socket.AF_INET,socket.SOCK_STREAM) except socket.error,msg: logger.error(\"create a socket failed\") try: listen_fd.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) except socket.error,msg: logger.error(\"setsocketopt error\") try: listen_fd.bind(('',10001)) except socket.error,msg: logger.error(\"listen file id bind ip error\") try: listen_fd.listen(10) except socket.error,msg: logger.error(msg) try: epoll_fd=select.epoll() epoll_fd.register(listen_fd.fileno(),select.EPOLLIN) except select.error,msg: logger.error(msg) connections={} addresses={} datalist={} while True: epoll_list = epoll_fd.poll() for fd,events in epoll_list: if fd==listen_fd.fileno(): conn,addr=listen_fd.accept() logger.debug(\"accept connction from %s,%d,fd = %d\" %(addr[0],addr[1],conn.fileno())) conn.setblocking(0) epoll_fd.register(conn.fileno(),select.EPOLLIN|select.EPOLLET) connections[conn.fileno()]=conn addresses[conn.fileno()]=addr elif select.EPOLLIN \u0026 events: datas='' while True: try: data=connections[fd].recv(10) if not data and not datas: epoll_fd.unregister(fd) connections[fd].close() logger.debug(\"%s,%d closed\" % (addresses[fd][0],addresses[fd][1])) break else: datas+=data except socket.error,msg: if msg.errno==errno.EAGAIN: logger.debug(\"%s receive %s\" % (fd,datas)) datalist[fd]=datas epoll_fd.modify(fd,select.EPOLLET|select.EPOLLOUT) break else: epoll_fd.unregister(fd) connections[fd].close() logger.error(msg) break elif select.EPOLLHUP \u0026 events: epoll_fd.unregister(fd) connections[fd].close() logger.debug(\"%s ,%d closed\" % (addresses[fd][0],addresses[fd][1])) elif select.EPOLLOUT \u0026 events: sendLen=0 while True: sendLen += connections[fd].send(datalist[fd][sendLen:]) if sendLen == len(datalist[fd]): break epoll_fd.modify(fd,select.EPOLLIN|select.EPOLLET) else: continue commontest.py(client code) import socket messages = [\"This is the message\", \"It will be send\", \"in parts\"] print \"Connect to the server\" server_address=(\"localhost\",10001) #Create a TCP/IP sock socks=[] for i in range(10): socks.append(socket.socket(socket.AF_INET,socket.SOCK_STREAM)) for s in socks: s.connect(server_address) counter=0 for message in messages: for s in socks: counter+=1 print \" %s sending %s \"%(s.getpeername(),message+\" version \"+str(counter)) s.send(message+\" version \"+str(counter)) for s in socks: data=s.recv(1024) print \" %s received %s \" % (s.getpeername(),data) if not data: print \"closing socket\",s.getpeername() s.close() 参考 epoll的使用 asyncore的介绍和使用-blog1 asyncore的介绍和使用-blog2 unix网络编程io模型 ","date":"2013-07-15","objectID":"/posts/2013/07/15/python-async-programming/:1:3","tags":["分布式","python"],"title":"使用python进行异步网络编程","uri":"/posts/2013/07/15/python-async-programming/"},{"categories":["linux"],"content":"ubuntu系统上安装多版本python语言环境 ","date":"2013-07-02","objectID":"/posts/2013/07/02/ubuntu-install-multi-python/:0:0","tags":["linux"],"title":"ubuntu系统上安装多版本python语言环境","uri":"/posts/2013/07/02/ubuntu-install-multi-python/"},{"categories":["linux"],"content":"ubuntu上安装多个版本的python 安装python3.3在ubuntu上 sudo apt-get install python-software-properties sudo add-apt-repository ppa:fkrull/deadsnakes sudo apt-get update sudo apt-get install python3.3 建立软链接： ln -s /usr/bin/python3.3 /usr/bin/python3.3m 安转python2.7.5再ubuntu上: sudo add-apt-repository ppa:fkrull/deadsnakes sudo apt-get update sudo apt-get install python2.4 python2.5 python2.6 使用virtualenv来定制自己的环境 virtualenv -p /usr/bin/python3.3 python3.3env virtualenv -p /usr/bin/python2.7.5 python2.7.5env Ok! ","date":"2013-07-02","objectID":"/posts/2013/07/02/ubuntu-install-multi-python/:0:1","tags":["linux"],"title":"ubuntu系统上安装多版本python语言环境","uri":"/posts/2013/07/02/ubuntu-install-multi-python/"},{"categories":["linux"],"content":"ubuntu系统上安装hdf5 ","date":"2013-06-05","objectID":"/posts/2013/06/05/ubuntu-install-hdf5/:0:0","tags":["linux","bigdata"],"title":"ubuntu上安装hdf5","uri":"/posts/2013/06/05/ubuntu-install-hdf5/"},{"categories":["linux"],"content":"install hdf5 on ubuntu 12.04 1.you can probably install the debian libraries into quantal with no issues, precise is less likely to work, but it might possibly you will have to build it from source to get everything right. Code: $apt-get install devscripts equivs ubuntu-dev-tools $pull-debian-source hdf5 experimental $cd hdf5-* $sudo mk-build-deps -ir $debuild -us -uc 2.上述方法现在已经不适用,Google后发现,可以直接使用hdf5二进制包,由于本机为64bit linux,下载64位下的二进制包: $wget http://www.hdfgroup.org/ftp/HDF5/releases/hdf5-1.8.9/bin/linux-x86_64/hdf5-1.8.9-linux-x86_64-shared.tar.gz 解压后，并在.bashrc中设置： $export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib:$HOME/hdf5-1.8.9-linux-x86_64-shared/lib $export HDF5_DIR=$HOME/hdf5-1.8.9-linux-x86_64-shared $source .bashrc 4.安装 blosc (可选) 5.安装 lzo2-2 lzo2-dev sudo apt-get install lzo2-2 lzo2-dev 至此HDF5可用 ","date":"2013-06-05","objectID":"/posts/2013/06/05/ubuntu-install-hdf5/:0:1","tags":["linux","bigdata"],"title":"ubuntu上安装hdf5","uri":"/posts/2013/06/05/ubuntu-install-hdf5/"},{"categories":null,"content":"You need to enable JavaScript to run this app. \r\r!function (l) {\rfunction e(e) {\rfor (var r, t, n = e[0], o = e[1], u = e[2], f = 0, i = []; f \r","date":"0001-01-01","objectID":"/page/tool/:0:0","tags":null,"title":"","uri":"/page/tool/"},{"categories":null,"content":" 关注软件开发、devops、python、golang、微服务、AI等技术。 ","date":"0001-01-01","objectID":"/page/archive/:0:0","tags":null,"title":"Archive","uri":"/page/archive/"},{"categories":null,"content":"联盟列表 forecho JACK LEE Ryan Yang Jimmy Song Roc RECALL’s Blog devopser sealyun wujunze (王丽兵)开发笔记 kuboard 风巢知识导航 猫爪导航 ","date":"0001-01-01","objectID":"/page/friend/:1:0","tags":null,"title":"联盟链接","uri":"/page/friend/"},{"categories":null,"content":"\r文章的部分内容被密码保护： \r\r--- DON'T MODIFY THIS LINE ---\r\r\r","date":"0001-01-01","objectID":"/page/project/:0:0","tags":null,"title":"项目","uri":"/page/project/"}]